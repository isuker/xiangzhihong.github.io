<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向志洪</title>
  <subtitle>这里只有代码相关，要了解更多 &gt;&gt;http://blog.csdn.net/xiangzhihong8</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://code.youmeek.com/"/>
  <updated>2017-01-25T03:08:48.824Z</updated>
  <id>http://code.youmeek.com/</id>
  
  <author>
    <name>向志洪</name>
    <email>1044817967@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序，会是下一个创业风口吗</title>
    <link href="http://code.youmeek.com/2017/01/05/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>http://code.youmeek.com/2017/01/05/搭建网站 - 副本/</id>
    <published>2017-01-04T16:00:00.000Z</published>
    <updated>2017-01-25T03:08:48.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序，创业者们的狂躁与迷思"><a href="#小程序，创业者们的狂躁与迷思" class="headerlink" title="小程序，创业者们的狂躁与迷思"></a>小程序，创业者们的狂躁与迷思</h1><p>记得在16年的9月份，就有消息说微信推出的小程序，一时间大家对于小程序的关注就从来没有减少过。或许是经过15年移动互联网大潮之后，16年互联网一下子寂静了许多的原因，大家对于小程序给予了很高的期望。我也从那时候起开始研究小程序，并且在12月的那次内测中，我也如愿的尝试了一把小程序的开发。<br>说实话，当时看着小程序的开发文档，惊艳了一下，呀，项目结构如此清晰，逻辑也是相当的清楚，一时间对微信平台架构的大神们膜拜了一下。相比原生的Android、ios开发，确实方便了不少，并且也是基于组件开发的，对于有前端、移动端开发经验的程序员是很容易上手的。<br>2016 年 12 月 28 日，张小龙在微信公开课 PRO 版的会场上，宣布了微信小程序的正式发布时间–2017 年 1 月 9 号正式上线。<br> 1 月 9 号如约而至，然后早上起床的时候突然就出现了微信里面多了个小程序入口。前提是你的微信更新至iOS6.5.3版本或Android6.5.3版本。如果你是安卓用户，还可以把小程序发送到桌面，在桌面上它看起来就像一个App无疑，不过其体验还是和原生相差很远，和React Native开发的app相比也差些火候。<br> <img src="http://img.blog.csdn.net/20170109202009364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 给我的第一感觉是，这是不是又是一个公众号，（mmd，居然三寨我们app的’s’图标，老张头，你可以的）。</p>
<h1 id="小程序的能与不能"><a href="#小程序的能与不能" class="headerlink" title="小程序的能与不能"></a>小程序的能与不能</h1><p> 那么问题来了，小程序到底能干什么？<br> 张小龙在微信公开课中称 ，“很多人看到微信开始内测小程序，说应该去获得一些流量上的红利，但是那就非常遗憾，公众号在微信里面其实也没有入口，小程序也是一样的。”<br> 据腾讯科技，做出这样的安排，与张小龙对小程序要承担的能力有关，而小程序要承担哪些能力，又基于张小龙对未来网络世界的思考。<br> 很多人将小程序和公众号拿来做对比，其实他们是有本质区别的。小程序与公众号的差异在于，小程序不能订阅、分发，推送受限，导致本身粘性降低，公众号重在优质内容价值，小程序更多是工具和场景价值，而流量和话语权更集中在微信平台。<br> 不过我到认为小程序其实是企鹅生态链的布局线：深挖商家价值，加码支付和O2O。说白了就是大公司圈底盘，然后阿里和百度就坐不住了，这里先不说小程序未来如何，至少我认为，它是不可能推翻传统app的，最多也只能发展为移动端的一个分发入口，这和用Facebook的RN开发大同小异，不过用RN的我相信会更多吧。<br> 小程序只做轻量级的应用，有点类似于百度的直达号，不过企鹅用多户嘛，大家知道的。这里放一张图，描述的是小程序服务分类。<br> <img src="http://img.blog.csdn.net/20170109204119836?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="小程序体验"><a href="#小程序体验" class="headerlink" title="小程序体验"></a>小程序体验</h1><p><strong>线下二维码</strong><br>微信主推线下二维码入口，所以线下二维码未来必将成为小程序入口中最重要的一部分。微信团队希望通过小程序，让很多线上线下原本难以连接的弱场景能够突破。但从我们第一波使用过得小程序来看，小程序的场景化使用尚有欠缺，不过未来肯定会重点推广二维码这个入口。<br><img src="http://mmbiz.qpic.cn/mmbiz_jpg/72UdicpfxJRJ7a5sc4gmju2WR9uVADbAkGJzyg6iaYOkIFslAb2bCLSKQg4Iicib2RCffAxVN5PHzicWqHOdSbsUlYg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="这里写图片描述"><br><strong>分享推荐</strong><br>小程序第二个获取通道是微信好友或群聊天的分享。所以，在短期内，微信群将成为小程序发声和传播的主要阵地。<br><img src="http://img.blog.csdn.net/20170109204535624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>关键词搜索</strong><br>也是现在大家用的最多的方式，直接在小程序的入口搜索。<br><img src="http://img.blog.csdn.net/20170109204705268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="微信小程序会做小程序商店吗"><a href="#微信小程序会做小程序商店吗" class="headerlink" title="微信小程序会做小程序商店吗"></a>微信小程序会做小程序商店吗</h2><p>在公开课上，张小龙明确表示，微信不会做小程序商店，只会做一个入口。</p>
<h2 id="小程序与订阅号的关系"><a href="#小程序与订阅号的关系" class="headerlink" title="小程序与订阅号的关系"></a>小程序与订阅号的关系</h2><p>相信很多人会关注这样一个问题，如果我们做一个公众号，我们会收获到很多的订阅用户（即粉丝），并且大家会从粉丝数来判断自己这个号的价值，但是小程序不会像订阅号，所以如果你做一个小程序，不能依赖于我的目的是要收获多少粉丝，粉丝并不意味着访问量，并不是说你有足够多的粉丝你就有足够大的访问量。<br>所以对于小程序来说也是一样的，它只有一种访问的关系，而不是一种粉丝的关系，所以它跟公众号从本质上来说是截然不同的，小程序不是一种公众号，它是一种新的形态。</p>
<h2 id="小程序能不能推送消息"><a href="#小程序能不能推送消息" class="headerlink" title="小程序能不能推送消息"></a>小程序能不能推送消息</h2><p>很多人会问小程序会不会像app那样做推送吗？答案是否定的。<br>因为如果小程序能推送消息的话，那就意味着你访问的每一个网站都会发一条消息给你，那你可能会崩溃掉，并且这种对于小程序的要求也会因此变高。</p>
<h2 id="小程序能不能做游戏"><a href="#小程序能不能做游戏" class="headerlink" title="小程序能不能做游戏"></a>小程序能不能做游戏</h2><p>很多人会问小程序能不能做游戏？答案是现在不能，不过不否定以后会有这种趋势。</p>
<h2 id="小程序和公众号什么关系"><a href="#小程序和公众号什么关系" class="headerlink" title="小程序和公众号什么关系"></a>小程序和公众号什么关系</h2><p>刚才大家明白了小程序和公众号是一种很独立的关系，但是因为很多的公众号和小程序他们可能是一个企业开发的，所以它们应该有某种关联，目前我们提供的一种关联是，你在公众号里面可以看到这个公众号同一个企业还做了哪些小程序，或者你在一个小程序里面你也可以看到，做这个小程序的企业还做了哪些公众号，他们是可以互相跳的。<br>还有一个小问题是，既然小程序会突出二维码，那么微信里面会不会对于线下的店会有一些提示，在目前这一阶段我们可能会很轻量地让用户能够看到在他附近还有哪些小程序存在，我们说的附近的小程序存在是指附近有哪些在提供服务的店，他们同时也有小程序。比如说在三公里以外有一个士多店，那么你可以看到并立即打开它的小程序，然后买一点什么东西，这是很有可能的。</p>
<h1 id="小程序开发"><a href="#小程序开发" class="headerlink" title="小程序开发"></a>小程序开发</h1><p>介绍这么多，那究竟怎么开发呢？别急，大家跟我来，之前也尝试了一把。<br><a href="http://blog.csdn.net/xiangzhihong8/article/details/53738417" target="_blank" rel="external">微信小程序环境搭建</a>、<a href="http://blog.csdn.net/xiangzhihong8/article/details/53862308" target="_blank" rel="external">微信小程序组件介绍</a>、<a href="http://blog.csdn.net/xiangzhihong8/article/details/53888087" target="_blank" rel="external">微信小程序摇一摇抽奖实例</a>、<a href="http://blog.csdn.net/xiangzhihong8/article/details/53888184" target="_blank" rel="external">微信小程序发布</a>、<a href="http://lib.csdn.net/base/wechat" target="_blank" rel="external">小程序知识库</a><br>就写这么多，希望大家喜欢!<br>附：<a href="https://github.com/web-Marker/wechat-Development" target="_blank" rel="external">芒果tv</a><br><a href="https://github.com/eyasliu/wechat-app-music" target="_blank" rel="external">音乐播放器</a></p>]]></content>
    
    <summary type="html">
    
      微信小程序
    
    </summary>
    
      <category term="微信" scheme="http://code.youmeek.com/categories/%E5%BE%AE%E4%BF%A1/"/>
    
    
      <category term="小程序" scheme="http://code.youmeek.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信" scheme="http://code.youmeek.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Angular2入坑指南</title>
    <link href="http://code.youmeek.com/2016/12/05/Angular2%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://code.youmeek.com/2016/12/05/Angular2入坑指南/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-01-25T03:04:28.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>对后端开发来说，前端是神秘的，眼花缭乱的技术，繁多的框架，出名的不出名的好几百种，看是“繁荣”，其实显得杂乱无章，但是我们在做开发的时候，技术选型还是主流的那么几个：浅析angular，react，vue.js Node.js。</p>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>官网：<a href="https://nodejs.org/" target="_blank" rel="external">https://nodejs.org/</a><br>nodejs不是一个js框架，千万不要认为是类似jquery的框架，nodejs是js运行时，运行环境，类比java中jvm。做前端的没用过nodejs都不好意思说自己是前端。nodejs是和jvm同等地位的js运行环境，打开了前端人员走向后端的道路。</p>
<h2 id="react-js"><a href="#react-js" class="headerlink" title="react.js"></a>react.js</h2><p>官网：<a href="http://facebook.github.io/react/" target="_blank" rel="external">http://facebook.github.io/react/</a><br>react是facebook前不久出的一款框架，众前端膜拜之。类比Java中freemarker的宏。reactjs最大的作用就是用来开发ui组件，比如用它开发移动端页面，也是今年移动端前端化的推动者。</p>
<h2 id="angular-js"><a href="#angular-js" class="headerlink" title="angular.js"></a>angular.js</h2><p>官网：<a href="http://www.apjs.net/" target="_blank" rel="external">http://www.apjs.net/</a><br>angular是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。因为背靠google也收到了开发者的推崇。</p>
<h1 id="概念与区别"><a href="#概念与区别" class="headerlink" title="概念与区别"></a>概念与区别</h1><p>本人也在React与Angular两大体系里纠结了好久，还使用React Native做了几个UI，彷徨于两大前端框架之前。<br>React缺点：</p>
<ol>
<li>Web Componet的MVC分离不够彻底。 JSX描述的页面模板与JS代码没有办法完全分开。<br>无法接受代码的同时还夹个HTML代码这样原始的方式。</li>
<li>对UI的描述自成一体，而不是采用CSS或者SCSS。</li>
<li>数据的传递不够直接还有一堆乱七八槽的属性</li>
<li>Android与IOS的代码不够一致</li>
<li>核心太小，一堆补充的库<br>Angular2的优点：<br>1、推荐TypeScript而不是原生的Javascript<br>2、类库特别多，概念也是特别多<br>3、体量大<br>4、成熟度相对偏低，版本2才刚发布<br>5、不兼容1.x<br>6、Router还不成熟<br>综合以上我最终决定选择Angular2作为我前端开发的首选框架。<br>同时还有以下几个Bonus：</li>
<li>配置nativescript写原生应用，并且nativescript支持css子集，这一点比react要强一些，可以更小的降低学习成本与维护成本。<ol>
<li>有官方的UI方案Material Design供选择</li>
<li>官工具链相对于React要成熟 有angular-cli这个便利化的工具，并提供E2E的测试，用以方便测试，并保证项目的质量。</li>
<li>维护团队强大<br>来看一张图：<br><img src="http://img.blog.csdn.net/20161225121233493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h1 id="Angular2快速安装与入门"><a href="#Angular2快速安装与入门" class="headerlink" title="Angular2快速安装与入门"></a>Angular2快速安装与入门</h1>安装angular-cli</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g angular-cli</div></pre></td></tr></table></figure>
<p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ng new PROJECT_NAMEcd PROJECT_NAMEng serve</div></pre></td></tr></table></figure>
<p>就这么 简单，这时候你的项目已经运行起来了。<br><img src="http://img.blog.csdn.net/20161225121618854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>我们看一下项目结构<br><img src="http://img.blog.csdn.net/20161225121652321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后打开localhost:4200就可以查看效果了。<br>附：<a href="https://github.com/angular/angular-cli" target="_blank" rel="external">angular-cli的教程与源码地址</a></p>]]></content>
    
    <summary type="html">
    
      对后端开发来说，前端是神秘的，眼花缭乱的技术，繁多的框架，出名的不出名的好几百种，看是“繁荣”，其实显得杂乱无章，但是我们在做开发的时候，技术选型还是主流的那么几个：浅析angular，React，vue.js Node.js。
    
    </summary>
    
      <category term="Angular2" scheme="http://code.youmeek.com/categories/Angular2/"/>
    
      <category term="前端" scheme="http://code.youmeek.com/categories/Angular2/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端开发" scheme="http://code.youmeek.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Angular2" scheme="http://code.youmeek.com/tags/Angular2/"/>
    
  </entry>
  
  <entry>
    <title>gulp+webpack工具整合简介</title>
    <link href="http://code.youmeek.com/2016/12/05/gulp+webpack%E5%B7%A5%E5%85%B7%E6%95%B4%E5%90%88%E7%AE%80%E4%BB%8B/"/>
    <id>http://code.youmeek.com/2016/12/05/gulp+webpack工具整合简介/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-01-25T03:06:59.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h2><p>Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><img src="http://img.blog.csdn.net/20170103123129506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="webpack特点"><a href="#webpack特点" class="headerlink" title="webpack特点"></a>webpack特点</h3><ul>
<li><p>Webpack<br>有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p>
</li>
<li><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript<br>模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p>
</li>
<li><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS<br>文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</p>
</li>
<li><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack<br>插件，来满足各式各样的需求。</p>
</li>
<li><p>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p>
</li>
</ul>
<h3 id="webpack配置及使用"><a href="#webpack配置及使用" class="headerlink" title="webpack配置及使用"></a>webpack配置及使用</h3><p>首先需要安装node环境和npm包管理工具，不知道的可以自行百度。基本环境好了后需要安装webpack插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack --save-dev</div></pre></td></tr></table></figure>
<p>接下来就是写一个demo验证了。创建一个静态页面 index.html 和一个 JS 入口文件 entry.js<br><!-- index.html --><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p> entry.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.write(&apos;It works.&apos;)</div></pre></td></tr></table></figure></p>
<p>编译 entry.js 并打包到 bundle.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack entry.js bundle.js</div></pre></td></tr></table></figure>
<p>然后在浏览器上就可以看到输出结果了“It works”。</p>
<h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先安装loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install css-loader style-loader</div></pre></td></tr></table></figure>
<p>然后我们写代码的时候通过require函数引入进来就可以了，具体使用请自行搜索。</p>
<h2 id="gulp-简介"><a href="#gulp-简介" class="headerlink" title="gulp 简介"></a>gulp 简介</h2><p>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。<br>gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。<br>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。</p>
<h3 id="gulp安装使用"><a href="#gulp安装使用" class="headerlink" title="gulp安装使用"></a>gulp安装使用</h3><h4 id="1、安装nodejs"><a href="#1、安装nodejs" class="headerlink" title="1、安装nodejs"></a>1、安装nodejs</h4><p>1.1、说明：gulp是基于nodejs，理所当然需要安装nodejs；<br>1.2、安装：打开<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs官网</a>，点击硕大的绿色Download按钮，它会根据系统信息选择对应版本（.msi文件）。然后一路next。</p>
<h4 id="2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）"><a href="#2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）" class="headerlink" title="2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）"></a>2、使用命令行（如果你熟悉命令行，可以直接跳到第3步）</h4><p>2.1、说明：什么是命令行？命令行在OSX是终端（Terminal），在windows是命令提示符（Command Prompt）；<br>2.2、注：之后操作都是在windows系统下；<br>2.3、简单介绍gulp在使用过程中常用命令，打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）：<br>node -v查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。PS：未能出现版本号，请尝试注销电脑重试；<br>npm -v查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器，那它有什么用呢？稍后解释；<br>cd定位到目录，用法：cd + 路径 ；<br>dir列出文件列表；<br>cls清空命令提示符窗口内容。<br><img src="http://img.blog.csdn.net/20170103204436639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="3、npm介绍"><a href="#3、npm介绍" class="headerlink" title="3、npm介绍"></a>3、npm介绍</h4><p>在这里直接略过，<a href="http://blog.csdn.net/xiangzhihong8/article/details/53422926" target="_blank" rel="external">npm详解</a></p>
<h4 id="4、选装cnpm"><a href="#4、选装cnpm" class="headerlink" title="4、选装cnpm"></a>4、选装cnpm</h4><p>4.1、说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个！来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”；<br>4.2、官方网址：<a href="http://npm.taobao.org；" target="_blank" rel="external">http://npm.taobao.org；</a><br>4.3、安装：命令提示符执行npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org；" target="_blank" rel="external">https://registry.npm.taobao.org；</a>  注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；<br>注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。</p>
<h4 id="5、全局安装gulp"><a href="#5、全局安装gulp" class="headerlink" title="5、全局安装gulp"></a>5、全局安装gulp</h4><p>5.1、说明：全局安装gulp目的是为了通过她执行gulp任务；<br>5.2、安装：命令提示符执行cnpm install gulp -g；<br>5.3、查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。</p>
<h4 id="6、新建package-json文件"><a href="#6、新建package-json文件" class="headerlink" title="6、新建package.json文件"></a>6、新建package.json文件</h4><p>这个也忽略，相当于maven组织项目的。</p>
<h4 id="7、本地安装gulp插件"><a href="#7、本地安装gulp插件" class="headerlink" title="7、本地安装gulp插件"></a>7、本地安装gulp插件</h4><p>7.1、安装：定位目录命令后提示符执行cnpm install –save-dev；<br>7.2、本示例以gulp-less为例（编译less文件），命令提示符执行cnpm install gulp-less –save-dev；<br><img src="http://img.blog.csdn.net/20170103205009580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>7.3、将会安装在node_modules的gulp-less目录下，该目录下有一个gulp-less的使用帮助文档README.md；<br>7.4、为了能正常使用，我们还得本地安装gulp：cnpm install gulp –save-dev；<br>PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。</p>
<h4 id="8、新建gulpfile-js文件（重要）"><a href="#8、新建gulpfile-js文件（重要）" class="headerlink" title="8、新建gulpfile.js文件（重要）"></a>8、新建gulpfile.js文件（重要）</h4><p>8.1、说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。<br>8.2、它大概是这样一个js文件（更多插件配置请<a href="http://www.ydcss.com/archives/tag/gulp" target="_blank" rel="external">查看这里</a>）<br>来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//导入工具包 require(&apos;node_modules里对应模块&apos;)</div><div class="line">var gulp = require(&apos;gulp&apos;), //本地安装gulp所用到的地方</div><div class="line">    less = require(&apos;gulp-less&apos;);</div><div class="line"> </div><div class="line">//定义一个testLess任务（自定义任务名称）</div><div class="line">gulp.task(&apos;testLess&apos;, function () &#123;</div><div class="line">    gulp.src(&apos;src/less/index.less&apos;) //该任务针对的文件</div><div class="line">        .pipe(less()) //该任务调用的模块</div><div class="line">        .pipe(gulp.dest(&apos;src/css&apos;)); //将会在src/css下生成index.css</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">gulp.task(&apos;default&apos;,[&apos;testLess&apos;, &apos;elseTask&apos;]); //定义默认任务 elseTask为其他任务，该示例没有定义elseTask任务</div><div class="line"> </div><div class="line">//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数</div><div class="line">//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) </div><div class="line">//gulp.dest(path[, options]) 处理完后文件生成路径</div></pre></td></tr></table></figure>
<h4 id="9、运行gulp"><a href="#9、运行gulp" class="headerlink" title="9、运行gulp"></a>9、运行gulp</h4><p>9.1、说明：命令提示符执行gulp 任务名称；<br>9.2、编译less：命令提示符执行gulp testLess；<br>9.3、当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’]。</p>
<h4 id="10、使用webstorm运行gulp任务"><a href="#10、使用webstorm运行gulp任务" class="headerlink" title="10、使用webstorm运行gulp任务"></a>10、使用webstorm运行gulp任务</h4><p>10.1、说明：使用webstorm可视化运行gulp任务；<br>10.2、使用方法：将项目导入webstorm，右键gulpfile.js 选择”Show Gulp Tasks”打开Gulp窗口，若出现”No task found”，选择右键”Reload tasks”，双击运行即可。<br><img src="http://img.blog.csdn.net/20170103211004745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="webpack-amp-gulp集成"><a href="#webpack-amp-gulp集成" class="headerlink" title="webpack&amp;gulp集成"></a>webpack&amp;gulp集成</h2><p>接下来要到重点了，gulp和webpack各有各的优点，那么我们整合这两个工具呢？</p>
<h3 id="创建webpack对象"><a href="#创建webpack对象" class="headerlink" title="创建webpack对象"></a>创建webpack对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var webpack = require(&quot;webpack&quot;)</div></pre></td></tr></table></figure>
<h3 id="创建gulp任务"><a href="#创建gulp任务" class="headerlink" title="创建gulp任务"></a>创建gulp任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//gulp --product</div><div class="line">gulp.task(&apos;default&apos;, function() &#123;</div><div class="line">  isProduct = argv.product;</div><div class="line">  isWatch = !isProduct;</div><div class="line">  console.log(&apos;正在处理：&apos; + (isProduct ? &apos;线上&apos; : &apos;本地&apos;) + &apos;环境&apos;);</div><div class="line">  fse.emptydirSync(&apos;./dist&apos;);</div><div class="line">  gulp.start(&apos;webpack&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ps:本地开发(命令：gulp)和线上(命令：gulp –product)部署gulp命令分开，本地会做文件更改的监听，并且不会压缩。</p>
<h3 id="webpack任务配置"><a href="#webpack任务配置" class="headerlink" title="webpack任务配置"></a>webpack任务配置</h3><p>入口文件配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">            index: &apos;./index.js&apos;</div><div class="line">            common: [</div><div class="line">                &apos;jquery&apos;,</div><div class="line">                &apos;understore&apos;,</div><div class="line">                &apos;template&apos;,</div><div class="line">                &apos;store&apos;</div><div class="line">            ]</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>该参数主要是配置入口文件，打包出来的文件就是以里面的key作为名字的文件（即bundle）。<br>输出路径配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">            path: &apos;./dist/&apos;,</div><div class="line">            filename: &apos;[name].js&apos;,</div><div class="line">            publicPath: &apos;&apos;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>别名配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">            alias: &#123;</div><div class="line">                jquery: path.resolve(&apos;../global/lib/jquery.js&apos;),</div><div class="line">                template: path.resolve(&apos;../global/lib/template.js&apos;),</div><div class="line">                understore: path.resolve(&apos;../global/lib/underscore.js&apos;),</div><div class="line">                store: path.resolve(&apos;../global/lib/store.js&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>配置完别名，就可以用别名来进行require了，不管是在webpack配置中，还是在js代码中。</p>
<h3 id="webpack插件配置"><a href="#webpack插件配置" class="headerlink" title="webpack插件配置"></a>webpack插件配置</h3><p>webpack内部全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new webpack.ProvidePlugin(&#123;</div><div class="line">    $: &apos;jquery&apos;,</div><div class="line">    jQuery: &apos;jquery&apos;,</div><div class="line">    template: &apos;template&apos;,</div><div class="line">    store: &apos;store&apos;,</div><div class="line">    _: &apos;understore&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>配置完全局的变量，在js中就直接可以用，不需要再require。该全局不是挂载到window对象上，只对webpack打包出来的js有用。<br>合并相同的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.DedupePlugin()</div></pre></td></tr></table></figure>
<p>说明:该插件会把相同的模块合并，不推荐使用，最好自己做到模块唯一性，如果打出来两个相同的模块，说明你的代码潜藏出错风险。<br>css抽离插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ExtractTextPlugin(&quot;[name].css&quot;)</div></pre></td></tr></table></figure>
<p>该插件会把css抽离出来作为单独的css文件进行打包，如果不使用该插件，会把css打包到js中，然后以style标签的形式，把css作为内联样式使用。<br>公共文件插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;, &apos;common.js&apos;)</div></pre></td></tr></table></figure>
<p>该插件会把公共的模块进行抽离到公共的js模块里面，防止js重复引用打包。<br>压缩插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        compress: &#123;</div><div class="line">            warnings: false</div><div class="line">        &#125;,</div><div class="line">        mangle: &#123;</div><div class="line">            except: [&apos;$&apos;, &apos;m&apos;, &apos;webpackJsonpCallback&apos;]</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>该插件会把js进行压缩，在线上环境进行使用。<br>注：mangle该关键词不需要混淆，因为在我们实践过程中，压缩后的代码有很多地方报错。<br>由于webpack会把所有的js都打包到一个js文件中，这样就不方便开发人员debug，故需要进行sourcemap的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devtool: (isProduct ? false : &apos;source-map&apos;)</div></pre></td></tr></table></figure>
<h3 id="加载器loader"><a href="#加载器loader" class="headerlink" title="加载器loader"></a>加载器loader</h3><p>js加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.js[x]?$/,</div><div class="line">    exclude: /node_modules/,</div><div class="line">    loader: &apos;babel-loader&apos;,</div><div class="line">    query: &#123;</div><div class="line">        compact: false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>js使用babel来进行加载，这样就可以使用一些es6的特性来开发，IE8下面使用如下方案来进行解决转换后的代码不兼容问题。</p>
<p>ps：解决IE8 babel 转换：我们把shim.js &amp; sham.js，自己合并到一起吧。<br>css、less、sass加载器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.css$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues&apos;)</div><div class="line">&#125;, &#123;</div><div class="line">    test: /\.less$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!less-loader&apos;)</div><div class="line">&#125;, &#123;</div><div class="line">    test: /\.scss$/,</div><div class="line">    loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!sass-loader&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ExtractTextPlugin是抽离css的插件。css-loader是处理css，会把url(xxx.png)处理成require，然后通过对应后缀名的其他加载器进行处理。==如果是线上环境，css会进行压缩，很多配置要进行调整如果直接采用默认的，转换后的css会出现一些问题，常见问题如：</p>
<ul>
<li>问题一，压缩后字体文件不能处理。解决方法：把iconfont.css里面的注释删除掉即可</li>
<li>问题二，压缩后的px单位会转换成pc,pt。解决方法：在加载器里面加上-convertValues参数。</li>
<li>问题三，css require的优先级问题，按照常理是后require的css是后加载。但是在实践过程中，(1)通过import引入的js模块中引入的css是优先于require引入的js模块中引入的css；(2)js中require的css名称如果和js所在模块的文件夹名字相同即使部分相同的话，优先级也会提高。</li>
<li>关于更多的问题请参照Loader配置。<br>图片字体文件加载器，file-loader：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.(png|jpg|gif|woff|woff2|ttf|eot|svg)$/,</div><div class="line">    loader: &quot;file-loader?name=[name]_[sha512:hash:base64:7].[ext]&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对一些图片和字体资源进行加载，我们会把相关文件抽离出来进行名字加上hash值的前7位做了处理后的名字。<br>html加载器;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.html/,</div><div class="line">    loader: &quot;html-loader&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="gulp脚本文件-重要"><a href="#gulp脚本文件-重要" class="headerlink" title="gulp脚本文件(重要)"></a>gulp脚本文件(重要)</h3><p>gulpfile.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">var gulp = require(&apos;gulp&apos;),</div><div class="line">    argv = require(&apos;yargs&apos;).argv,</div><div class="line">    fs = require(&apos;fs&apos;),</div><div class="line">    fse = require(&apos;fs-extra&apos;),</div><div class="line">    path = require(&apos;path&apos;),</div><div class="line">    util = require(&apos;util&apos;);</div><div class="line">var webpack = require(&quot;webpack&quot;),</div><div class="line">    ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line"></div><div class="line">var isWatch = true;</div><div class="line">var isProduct = false;</div><div class="line">var project = &apos;iwjw-pc&apos;;</div><div class="line">//gulp --product</div><div class="line">gulp.task(&apos;default&apos;, function() &#123;</div><div class="line">    isProduct = argv.product;</div><div class="line">    isWatch = !isProduct;</div><div class="line"></div><div class="line">    console.log(&apos;正在处理：&apos; + (isProduct ? &apos;线上&apos; : &apos;本地&apos;) + &apos;环境&apos;);</div><div class="line"></div><div class="line">    fse.emptydirSync(&apos;./dist&apos;);</div><div class="line"></div><div class="line">    gulp.start(&apos;webpack&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//webpack静态处理</div><div class="line">gulp.task(&apos;webpack&apos;, function(callback) &#123;</div><div class="line">    var minfy = [];</div><div class="line">    isProduct &amp;&amp; minfy.push(new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">        compress: &#123;</div><div class="line">            warnings: false</div><div class="line">        &#125;,</div><div class="line">        mangle: &#123;</div><div class="line">            except: [&apos;$&apos;, &apos;m&apos;, &apos;webpackJsonpCallback&apos;]</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    //webpack配置文件</div><div class="line">    var config = &#123;</div><div class="line">        watch: isWatch,</div><div class="line">        entry: &#123;</div><div class="line">            index: &apos;./index.js&apos;,</div><div class="line">            common: [</div><div class="line">                &apos;jquery&apos;,</div><div class="line">                &apos;understore&apos;,</div><div class="line">                &apos;template&apos;,</div><div class="line">                &apos;store&apos;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        debug: true,</div><div class="line"></div><div class="line">        devtool: (isProduct ? false : &apos;source-map&apos;),</div><div class="line"></div><div class="line">        output: &#123;</div><div class="line">            path: &apos;./dist/&apos;,</div><div class="line">            filename: &apos;[name].js&apos;,</div><div class="line">            publicPath: &apos;&apos;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        resolve: &#123;</div><div class="line">            alias: &#123;</div><div class="line">                jquery: path.resolve(&apos;../global/lib/jquery.js&apos;),</div><div class="line">                template: path.resolve(&apos;../global/lib/template.js&apos;),</div><div class="line">                understore: path.resolve(&apos;../global/lib/underscore.js&apos;),</div><div class="line">                store: path.resolve(&apos;../global/lib/store.js&apos;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line"></div><div class="line">        plugins: [</div><div class="line">            new webpack.ProvidePlugin(&#123;</div><div class="line">                $: &apos;jquery&apos;,</div><div class="line">                jQuery: &apos;jquery&apos;,</div><div class="line">                template: &apos;template&apos;,</div><div class="line">                store: &apos;store&apos;,</div><div class="line">                _: &apos;understore&apos;</div><div class="line">            &#125;),</div><div class="line">            new webpack.optimize.DedupePlugin(),</div><div class="line">            new ExtractTextPlugin(&quot;[name].css&quot;),</div><div class="line">            new webpack.optimize.CommonsChunkPlugin(&apos;common&apos;, &apos;common.js&apos;)</div><div class="line">        ].concat(minfy),</div><div class="line">        module: &#123;</div><div class="line">            loaders: [&#123;</div><div class="line">                test: /\.js[x]?$/,</div><div class="line">                exclude: /node_modules/,</div><div class="line">                loader: &apos;babel-loader&apos;,</div><div class="line">                query: &#123;</div><div class="line">                    compact: false</div><div class="line">                &#125;</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.css$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.less$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!less-loader&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.scss$/,</div><div class="line">                loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader?-convertValues!sass-loader&apos;)</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.(png|jpg|gif|woff|woff2|ttf|eot|svg)$/,</div><div class="line">                loader: &quot;file-loader?name=[name]_[sha512:hash:base64:7].[ext]&quot;</div><div class="line">            &#125;, &#123;</div><div class="line">                test: /\.html/,</div><div class="line">                loader: &quot;html-loader&quot;</div><div class="line">            &#125;]</div><div class="line">        &#125;</div><div class="line">    &#125;; </div><div class="line">    webpack(config, function(err, stats) &#123;</div><div class="line">        console.log(stats.toString());</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">gulp.task(&apos;sham&apos;, function()&#123;</div><div class="line">    gulp.src(&apos;../global/lib/es5-shim-sham.js&apos;).pipe(gulp.dest(&apos;./dist&apos;));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>pacakge.json（根据项目情况配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;name&quot;: &quot;iwfe&quot;,</div><div class="line">&quot;version&quot;: &quot;0.0.0&quot;,</div><div class="line">&quot;private&quot;: true,</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  &quot;start&quot;: &quot;node ./bin/server&quot;</div><div class="line">&#125;,</div><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">  &quot;babel-loader&quot;: &quot;^5.3.2&quot;,</div><div class="line">  &quot;bundle-loader&quot;: &quot;^0.5.4&quot;,</div><div class="line">  &quot;css-loader&quot;: &quot;^0.16.0&quot;,</div><div class="line">  &quot;exports-loader&quot;: &quot;^0.6.2&quot;,</div><div class="line">  &quot;extract-text-webpack-plugin&quot;: &quot;^0.8.2&quot;,</div><div class="line">  &quot;file-loader&quot;: &quot;~0.8.4&quot;,</div><div class="line">  &quot;fs-extra&quot;: &quot;*&quot;,</div><div class="line">  &quot;html-loader&quot;: &quot;^0.4.0&quot;,</div><div class="line">  &quot;imports-loader&quot;: &quot;^0.6.5&quot;,</div><div class="line">  &quot;jquery&quot;: &quot;~2.1.4&quot;,</div><div class="line">  &quot;sass-loader&quot;: &quot;^3.1.2&quot;,</div><div class="line">  &quot;source-map-loader&quot;: &quot;^0.1.5&quot;,</div><div class="line">  &quot;style-loader&quot;: &quot;~0.12.3&quot;,</div><div class="line">  &quot;through2&quot;: &quot;*&quot;,</div><div class="line">  &quot;url-loader&quot;: &quot;~0.5.6&quot;,</div><div class="line">  &quot;webpack&quot;: &quot;*&quot;,</div><div class="line">  &quot;webpack-dev-server&quot;: &quot;^1.10.1&quot;,</div><div class="line">  &quot;yargs&quot;: &quot;*&quot;,</div><div class="line">  &quot;gulp-zip&quot;: &quot;*&quot;</div><div class="line">&#125;,</div><div class="line">&quot;devDependencies&quot;: &#123;</div><div class="line">  &quot;gulp&quot;: &quot;*&quot;,</div><div class="line">  &quot;gulp-util&quot;: &quot;*&quot;</div><div class="line">&#125;,</div><div class="line">&quot;description&quot;: &quot;前端静态库&quot;,</div><div class="line">&quot;repository&quot;: &#123;</div><div class="line">  &quot;type&quot;: &quot;git&quot;,</div><div class="line">  &quot;url&quot;: &quot;xxx&quot;</div><div class="line">&#125;,</div><div class="line">&quot;author&quot;: &quot;jade&quot;,</div><div class="line">&quot;license&quot;: &quot;ISC&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：<a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">http://www.ydcss.com/archives/18</a><br><a href="https://github.com/webpack" target="_blank" rel="external">https://github.com/webpack</a></p>]]></content>
    
    <summary type="html">
    
      Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。
    
    </summary>
    
      <category term="gulp" scheme="http://code.youmeek.com/categories/gulp/"/>
    
      <category term="前端" scheme="http://code.youmeek.com/categories/gulp/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端开发" scheme="http://code.youmeek.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="webpack" scheme="http://code.youmeek.com/tags/webpack/"/>
    
      <category term="gulp" scheme="http://code.youmeek.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://code.youmeek.com/2016/12/05/swift/"/>
    <id>http://code.youmeek.com/2016/12/05/swift/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-01-24T08:23:08.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文来自Swift中文开发组，感谢翻译者的分享。<br>本文将分几部分对Swift对iOS的语法做讲解。本文为第一节，主要讲解基础语法。<br>常量和变量</p>
<p>常量和变量把一个名字（比如maximumNumberOfLoginAttempts或者welcomeMessage）和一个指定类型的值（比如数字10或者字符串”Hello”）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。<br>声明常量和变量</p>
<p>常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0<br>这两行代码可以被理解为：“声明一个名字是maximumNumberOfLoginAttempts的新常量，并给它一个值10。然后，声明一个名字是currentLoginAttempt的变量并将它的值初始化为0.”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var x = 0.0, y = 0.0, z = 0.0<br>注意：如果你的代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量。<br>类型标注</p>
<p>当你声明常量或者变量的时候可以加上类型标注(type annotation)，说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给welcomeMessage变量添加了类型标注，表示这个变量可以存储String类型的值：<br>[html] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var welcomeMessage: String<br>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：“声明一个类型为String，名字为welcomeMessage的变量。”</p>
<p>“类型为String”的意思是“可以存储任意String类型的值。”</p>
<p>welcomeMessage变量现在可以被设置成任意字符串：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>welcomeMessage = “Hello”<br>注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给welcomeMessage赋初始值，所以变量welcomeMessage的类型是通过一个类型标注指定的，而不是通过初始值推断的。<br>常量和变量的命名</p>
<p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let π = 3.14159<br>let 你好 = “你好世界”<br>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。<br>注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。<br>你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从”Hello!”改为了”Bonjour!”:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome 现在是 “Bonjour!”<br>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let languageName = “Swift”<br>languageName = “Swift++”<br>// 这会报编译时错误 - languageName 不可改变<br>输出常量和变量</p>
<p>你可以用println函数来输出当前常量或变量的值:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(friendlyWelcome) // 输出 “Bonjour!”<br>println是一个用来输出的全局函数，输出的内容会在最后换行。如果你用 Xcode，println将会输出内容到“console”面板上。(另一种函数叫print，唯一区别是在输出内容最后不会换行。)</p>
<p>println函数输出传入的String值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“This is a string”) // 输出 “This is a string”<br>与 Cocoa 里的NSLog函数类似的是，println函数可以输出更复杂的信息。这些信息可以包含当前常量和变量的值。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// 输出 “The current value of friendlyWelcome is Bonjour!<br>注意：字符串插值所有可用的选项，请参考字符串插值。</p>
<p>注释</p>
<p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与C 语言的注释非常相似。单行注释以双正斜杠作(//)为起始标记；<br>// 这是一个注释<br>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号(/<em>)，终止标记为一个星号后跟随单个正斜杠(</em>/)<br>/<em> 这是一个, 多行注释 </em>/<br>与C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：<br>/<em> 这是第一个多行注释的开头<br>/</em> 这是第二个被嵌套的多行注释 <em>/<br>这是第一个多行注释的结尾 </em>/<br>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p>分号</p>
<p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let cat = “<br>整数</p>
<p>整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是UInt8，32位有符号整数类型是Int32。就像 Swift 的其他类型一样，整数类型采用大写命名法。<br>整数范围</p>
<p>你可以访问不同整数类型的min和max属性来获取对应类型的最大值和最小值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let minValue = UInt8.min // minValue 为 0，是 UInt8 类型的最小值<br>let maxValue = UInt8.max // maxValue 为 255，是 UInt8 类型的最大值<br>Int</p>
<p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：<br>在32位平台上，Int和Int32长度相同。<br>在64位平台上，Int和Int64长度相同。</p>
<p>除非你需要特定长度的整数，一般来说使用Int就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int可以存储的整数范围也可以达到-2147483648~2147483647，大多数时候这已经足够大了。<br>UInt</p>
<p>Swift 也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同：<br>在32位平台上，UInt和UInt32长度相同。<br>在64位平台上，UInt和UInt64长度相同。<br>注意：尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用Int，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推测，请参考类型安全和类型推测。<br>浮点数</p>
<p>浮点数是有小数部分的数字，比如3.14159，0.1和-273.15。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比Int类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：<br>Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。<br>Float表示32位浮点数。精度要求不高的话可以使用此类型。<br>注意：Double精确度很高，至少有15位数字，而Float最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。<br>类型安全和类型推测</p>
<p>Swift 是一个类型安全(type safe )的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查(type checks)，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推测(type inference)来选择合适的类型。有了类型推测，编译器可以在编译代码的时候自动推测出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推测，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推测非常有用。当你在声明常量或者变量的时候赋给它们一个字面量(literal value 或 literal)即可触发类型推测。（字面量就是会直接出现在你代码中的值，比如42和3.14159。）</p>
<p>例如，如果你给一个新常量赋值42并且没有标明类型，Swift 可以推测出常量类型是Int，因为你给它赋的初始值看起来像一个整数：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型<br>同理，如果你没有给浮点字面量标明类型，Swift 会推测你想要的是Double：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let pi = 3.14159 // pi 会被推测为 Double 类型<br>当推测浮点数的类型时，Swift 总是会选择Double而不是Float。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推测为Double类型：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let anotherPi = 3 + 0.14159 // anotherPi 会被推测为 Double 类型<br>原始值3没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推测为Double类型。<br>数值型字面量</p>
<p>整数字面量可以被写作：<br>一个十进制数，没有前缀<br>一个二进制数，前缀是0b<br>一个八进制数，前缀是0o<br>一个十六进制数，前缀是0x</p>
<p>下面的所有整数字面量的十进制值都是17:<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let decimalInteger = 17<br>let binaryInteger = 0b10001 // 二进制的17<br>let octalInteger = 0o21 // 八进制的17<br>let hexadecimalInteger = 0x11 // 十六进制的17<br>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是0x）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的指数(exponent)，在十进制浮点数中通过大写或者小写的e来指定，在十六进制浮点数中通过大写或者小写的p来指定。</p>
<p>如果一个十进制数的指数为exp，那这个数相当于基数和$10^{exp}$的乘积：<br>1.25e2 表示 $1.25 × 10^{2}$，等于 125.0。<br>1.25e-2 表示 $1.25 × 10^{-2}$，等于 0.0125。</p>
<p>如果一个十六进制数的指数为exp，那这个数相当于基数和$2^{exp}$的乘积：<br>0xFp2 表示 $15 × 2^{2}$，等于 60.0。<br>0xFp-2 表示 $15 × 2^{-2}$，等于 3.75。</p>
<p>下面的这些浮点字面量都等于十进制的12.1875：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0<br>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let paddedDouble = 000123.456<br>let oneMillion = 1_000_000<br>let justOverOneMillion = 1_000_000.000_000_1<br>数值型类型转换</p>
<p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用Int类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推测。 只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。<br>整数转换</p>
<p>不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字范围是-128~127，而UInt8类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let cannotBeNegative: UInt8 = -1 // UInt8 类型不能存储负数，所以会报错<br>let tooBig: Int8 = Int8.max + 1 // Int8 类型不能存储超过最大值的数，所以会报错<br>由于每中整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是Uint8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)<br>现在两个数字的类型都是UInt16，可以进行相加。目标常量twoThousandAndOne的类型被推测为UInt16，因为它是两个UInt16值的和。</p>
<p>SomeType(ofInitialValue)是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的UInt8来创建一个新的UInt16。注意，你并不能传入任意类型的值，只能传入UInt16内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考扩展。<br>整数和浮点数转换</p>
<p>整数和浮点数的转换必须显式指定类型：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi 等于 3.14159，所以被推测为 Double 类型<br>这个例子中，常量three的值被用来创建一个Double类型的值，所以加号两边的数类型相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用Double或者Float类型来初始化：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let integerPi = Int(pi) // integerPi 等于 3，所以被推测为 Int 类型<br>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说4.75会变成4，-3.9会变成-3。<br>注意：结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。<br>类型别名</p>
<p>类型别名(type aliases)就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>typealias AudioSample = UInt16<br>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound 现在是 0<br>本例中，AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0。<br>布尔值</p>
<p>Swift 有一个基本的布尔(Boolean)类型，叫做Bool。布尔值指逻辑上的(logical)，因为它们只能是真或者假。Swift 有两个布尔常量，true和false：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let orangesAreOrange = true<br>let turnipsAreDelicious = false<br>orangesAreOrange和turnipsAreDelicious的类型会被推测为Bool，因为它们的初值是布尔字面量。就像之前提到的Int和Double一样，如果你创建变量的时候给它们赋值true或者false，那你不需要将常量或者变量声明为Bool类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推测，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如if语句的时候，布尔值非常有用：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if turnipsAreDelicious {<br>    println(“Mmm, tasty turnips!”)<br>} else {<br>    println(“Eww, turnips are horrible.”)<br>}<br>// 输出 “Eww, turnips are horrible.”<br>条件语句，例如if，请参考控制流。</p>
<p>如果你在需要使用Bool类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let i = 1 if i { // 这个例子不会通过编译，会报错 }<br>然而，下面的例子是合法的：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let i = 1 if i == 1 { // 这个例子会编译成功 }<br>i == 1的比较结果是Bool类型，所以第二个例子可以通过类型检查。类似i == 1这样的比较，请参考基本操作符。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。<br>元组</p>
<p>元组（tuples）把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，(404, “Not Found”)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let http404Error = (404, “Not Found”) // http404Error 的类型是 (Int, String)，值是 (404, “Not Found”)<br>(404, “Not Found”)元组把一个Int值和一个String值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为(Int, String)的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为(Int, Int, Int)或者(String, Bool)或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let (statusCode, statusMessage) = http404Error<br>println(“The status code is (statusCode)”)<br>// 输出 “The status code is 404”<br>println(“The status message is (statusMessage)”)<br>// 输出 “The status message is Not Found”<br>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<em>）标记：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let (justTheStatusCode, </em>) = http404Error<br>println(“The status code is (justTheStatusCode)”)<br>// 输出 “The status code is 404”<br>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The status code is (http404Error.0)”) // 输出 “The status code is 404”<br>println(“The status message is (http404Error.1)”) // 输出 “The status message is Not Found”<br>你可以在定义元组的时候给单个元素命名：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let http200Status = (statusCode: 200, description: “OK”)<br>给元组中的元素命名后，你可以通过名字来获取这些元素的值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>println(“The status code is (http200Status.statusCode)”) // 输出 “The status code is 200”<br>println(“The status message is (http200Status.description)”) // 输出 “The status message is OK”<br>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个(Int, String)元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考[函数参数与返回值(06_Functions.html#Function_Parameters_and_Return_Values)。<br>注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考类和结构体。<br>可选</p>
<p>使用可选（optionals）来处理值可能缺失的情况。可选表示：<br>有值，等于 x<br>或者<br>没有值<br>注意：C 和 Objective-C 中并没有可选这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选可以让你暗示任意类型的值缺失，并不需要一个特殊值。<br>来看一个例子。Swift 的String类型有一个叫做toInt的方法，作用是将一个String值转换成一个Int值。然而，并不是所有的字符串都可以转换成一个整数。字符串”123”可以被转换成数字123，但是字符串”hello, world”不行。</p>
<p>下面的例子使用toInt方法来尝试将一个String转换成Int：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let possibleNumber = “123”<br>let convertedNumber = possibleNumber.toInt()<br>// convertedNumber 被推测为类型 “Int?”， 或者类型 “optional Int”<br>因为toInt方法可能会失败，所以它返回一个可选的（optional）Int，而不是一个Int。一个可选的Int被写作Int?而不是Int。问号暗示包含的值是可选，也就是说可能包含Int值也可能不包含值。（不能包含其他任何值比如Bool值或者String值。只能是Int或者什么都没有。）<br>if 语句以及强制解析</p>
<p>你可以使用if语句来判断一个可选是否包含值。如果可选有值，结果是true；如果没有值，结果是false。</p>
<p>当你确定可选包确实含值之后，你可以在可选的名字后面加一个感叹号(!)来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if convertedNumber {<br>    println(“(possibleNumber) has an integer value of (convertedNumber!)”)<br>} else {<br>    println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br>更多关于if语句的内容，请参考控制流。<br>注意：使用!来获取一个不存在的可选值会导致运行时错误。使用!来强制解析值之前，一定要确定可选包含一个非nil的值。<br>可选绑定</p>
<p>使用可选绑定（optional binding）来判断可选是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在if和while语句中来对可选的值进行判断并把值赋给一个常量或者变量。if和while语句，请参考控制流。</p>
<p>像下面这样在if语句中写一个可选绑定：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let constantName = someOptional { statements }<br>你可以像上面这样使用可选绑定来重写possibleNumber这个例子：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let actualNumber = possibleNumber.toInt() {<br>    println(“(possibleNumber) has an integer value of (actualNumber)”)<br>} else {<br>    println(“(possibleNumber) could not be converted to an integer”)<br>}<br>// 输出 “123 has an integer value of 123”<br>这段代码可以被理解为：“如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，actualNumber常量可以在if语句的第一个分支中使用。它已经被可选包含的值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，actualNumber只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作actualNumber的值，你可以改成if var actualNumber，这样可选包含的值就会被赋给一个变量而非常量。<br>nil</p>
<p>你可以给可选变量赋值为nil来表示它没有值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var serverResponseCode: Int? = 404  // serverResponseCode 包含一个可选的 Int 值 404<br>serverResponseCode = nil // serverResponseCode 现在不包含值<br>注意：nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。<br>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>var surveyAnswer: String? // surveyAnswer 被自动设置为 nil</p>
<p>注意：Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。在 Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选都可以被设置为nil，不只是对象类型。<br>隐式解析可选</p>
<p>如上所述，可选暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选被定义为隐式解析可选（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选。</p>
<p>当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中，请参考类实例之间的循环强引用。</p>
<p>一个隐式解析可选其实就是一个普通的可选，但是可以被当做非可选来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选String和隐式解析可选String之间的区别：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>let possibleString: String? = “An optional string.”<br>println(possibleString!) // 需要惊叹号来获取值<br>// 输出 “An optional string.”<br>let assumedString: String! = “An implicitly unwrapped optional string.”<br>println(assumedString) // 不需要感叹号<br>// 输出 “An implicitly unwrapped optional string.”<br>你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。<br>注意：如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。<br>你仍然可以把隐式解析可选当做普通可选来判断它是否包含值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if assumedString {<br>    println(assumedString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>你也可以在可选绑定中使用隐式解析可选来检查并解析它的值：<br>[objc] view plain copy print?在CODE上查看代码片派生到我的代码片<br>if let definiteString = assumedString {<br>    println(definiteString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>注意：如果一个变量之后可能变成nil的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>]]></content>
    
    <summary type="html">
    
      Swift基础语法3.0
    
    </summary>
    
      <category term="ios" scheme="http://code.youmeek.com/categories/ios/"/>
    
    
      <category term="ios" scheme="http://code.youmeek.com/tags/ios/"/>
    
      <category term="swift" scheme="http://code.youmeek.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>node.js基本工作原理及流程</title>
    <link href="http://code.youmeek.com/2016/12/05/Node.js%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://code.youmeek.com/2016/12/05/Node.js基本工作原理/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-01-25T03:03:13.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h2><p>Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。<br>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</p>
<h2 id="什么是v8引擎"><a href="#什么是v8引擎" class="headerlink" title="什么是v8引擎"></a>什么是v8引擎</h2><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎。很少有人考虑 JavaScript 在客户机上实际做了些什么？实际上，JavaScript 引擎负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；您可以下载该引擎并将其嵌入任何 应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p>
<h2 id="Node-js的作用"><a href="#Node-js的作用" class="headerlink" title="Node.js的作用"></a>Node.js的作用</h2><p>Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java™ 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。<br>而Node的出现就是为了解决这个问题：更改连接到服务器的方式。在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。</p>
<h2 id="Node-js能做什么"><a href="#Node-js能做什么" class="headerlink" title="Node.js能做什么"></a>Node.js能做什么</h2><p>借用一句经典的描述Node.js的话:正如 JavaScript 为客户端而生，Node.js 为网络而生。<br>使用Node.js，你可以轻易的实现：</p>
<ul>
<li>具有复杂逻辑的网站；</li>
<li>基于社交网络的大规模 Web 应用；</li>
<li>Web Socket 服务器；</li>
<li>TCP/UDP 套接字应用程序；</li>
<li>命令行工具；</li>
<li>交互式终端程序；</li>
<li>带有图形用户界面的本地应用程序；</li>
<li>单元测试工具；</li>
<li>客户端 JavaScript 编译器。</li>
</ul>
<h2 id="什么是事件驱动编程"><a href="#什么是事件驱动编程" class="headerlink" title="什么是事件驱动编程"></a>什么是事件驱动编程</h2><p>在我们使用Java，PHP等语言实现编程的时候，我们面向对象编程是完美的编程设计，这使得他们对其他编程方法不屑一顾。却不知大名鼎鼎Node使用的却是事件驱动编程的思想。那什么是事件驱动编程。<br><strong>事件驱动编程，为需要处理的事件编写相应的事件处理程序。代码在事件发生时执行。</strong><br>为需要处理的事件编写相应的事件处理程序。要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu。<br>来看一张简单的事件驱动模型（uml）：</p>
<p><img src="http://img.blog.csdn.net/20161231115520916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p>
<ul>
<li>事件源：产生事件的地方(html元素)</li>
<li>事件：点击/鼠标操作/键盘操作等等</li>
<li>事件对象：当某个事件发生时，可能会产生一个事件对象，该时间对象会封装好该时间的信息，传递给事件处理程序</li>
<li>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt; </div><div class="line">   &lt;head&gt; </div><div class="line">   &lt;script&gt; </div><div class="line">   function test1(e)&#123; </div><div class="line">     window.alert(&quot;x=&quot;+e.clientX+&quot;y=&quot;+e.clientY); </div><div class="line">   &#125; </div><div class="line">   &lt;/script&gt; </div><div class="line">   &lt;/head&gt; </div><div class="line">   &lt;body onmousedown=&quot;test1(event)&quot;&gt; </div><div class="line">   &lt;/body&gt; </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h1 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h1><p>当我们搜索Node.js时，夺眶而出的关键字就是 “单线程，异步I/O，事件驱动”，应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务。<br>    所以I/O才是应用程序的瓶颈所在，在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>     但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但操作系统在内核切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。<br> 那么是否可以另辟蹊径呢？！我们先来看看单线程，《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：<br> <img src="http://img.blog.csdn.net/20161231120417621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。<br> I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br> 在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p>
<h1 id="Node-js的简单实践"><a href="#Node-js的简单实践" class="headerlink" title="Node.js的简单实践"></a>Node.js的简单实践</h1><p> 关于node的环境搭建这里就不说明了<a href="http://blog.csdn.net/xiangzhihong8/article/details/52842061" target="_blank" rel="external">node入门</a>。这里为了方便大家理解，我们写一个简单的登录实例。<br> 这里为了方便前端小白的理解，新增一个小节，如何使用Node搭建一个新的项目。</p>
<h2 id="使用Node创建项目"><a href="#使用Node创建项目" class="headerlink" title="使用Node创建项目"></a>使用Node创建项目</h2><p> 安装Express</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g express  </div><div class="line">npm install -g express-generator</div></pre></td></tr></table></figure>
<p>新建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">express -t ejs newsproject</div></pre></td></tr></table></figure></p>
<p>按照提示进入项目目录，运行npm安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd newsprojec</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>运行项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node app.js</div></pre></td></tr></table></figure>
<p>浏览器访问:<a href="http://127.0.0.1:3000/即可见nodejs站点页面即可。" target="_blank" rel="external">http://127.0.0.1:3000/即可见nodejs站点页面即可。</a><br>接下来我们写一个简单的例子，来看一下效果图：<br><img src="http://img.blog.csdn.net/20161231215128577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 整个目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">根目录--------------</div><div class="line">    |-package.json</div><div class="line">    |-test.js</div><div class="line">    |-public</div><div class="line">        |-main.html</div><div class="line">        |-next.html</div></pre></td></tr></table></figure></p>
<p>整个目录包含三个文件，test.js（作为控制文件）、main.html和next.html作为页面的显示文件。<br>来看一下代码：<br>test.js（作为控制文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// file name :test.js</div><div class="line">var express             = require(&apos;express&apos;);</div><div class="line">var app                 = express();</div><div class="line">var bodyParse           = require(&apos;body-parser&apos;)</div><div class="line">var cookieParser        = require(&apos;cookie-parser&apos;) ;</div><div class="line">app.use(cookieParser()) ;</div><div class="line">app.use(bodyParse.urlencoded(&#123;extended:false&#125;)) ;</div><div class="line"></div><div class="line">// 处理根目录的get请求</div><div class="line">app.get(&apos;/&apos;,function(req,res)&#123;</div><div class="line">    res.sendfile(&apos;public/main.html&apos;) ;</div><div class="line">    console.log(&apos;main page is required &apos;);</div><div class="line">&#125;) ;</div><div class="line"></div><div class="line">// 处理/login的get请求</div><div class="line">app.get(&apos;/add&apos;, function (req,res) &#123;</div><div class="line">    res.sendfile(&apos;public/add.html&apos;) ;</div><div class="line">    console.log(&apos;add page is required &apos;) ;</div><div class="line">&#125;) ;</div><div class="line"></div><div class="line">// 处理/login的post请求</div><div class="line">app.post(&apos;/login&apos;,function(req,res)&#123;</div><div class="line">    name=req.body.name ;</div><div class="line">    pwd=req.body.pwd   ;</div><div class="line">    console.log(name+&apos;--&apos;+pwd) ;</div><div class="line">    res.status(200).send(name+&apos;--&apos;+pwd) ;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 监听3000端口</div><div class="line">var server=app.listen(3000) ;</div></pre></td></tr></table></figure>
<p>main.html的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://fonts.useso.com/css?family=Tangerine|Inconsolata|Droid+Sans&quot;&gt;</div><div class="line"></div><div class="line">    &lt;style&gt;</div><div class="line">        div#test&#123;</div><div class="line">            font-family: &apos;Tangerine&apos;,serif;</div><div class="line">            font-size: 48px;</div><div class="line">        &#125;</div><div class="line">        p#link1&#123;</div><div class="line">            font-family: &apos;Tangerine&apos;,serif;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/style&gt;</div><div class="line"></div><div class="line">    &lt;script src=&quot;//cdn.bootcss.com/jquery/2.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;test&quot;&gt;</div><div class="line">    &lt;h1&gt;Main Page&lt;/h1&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;p&gt;Register &amp; Login&lt;/p&gt;</div><div class="line">&lt;form action=&quot;test.jsp&quot; method=&quot;post&quot;&gt;</div><div class="line">    账号 :</div><div class="line">    &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;</div><div class="line">    &lt;br/&gt;&lt;br/&gt;</div><div class="line">    密码 :</div><div class="line">    &lt;input type=&quot;text&quot; id=&quot;pwd&quot; /&gt;</div><div class="line">    &lt;br/&gt;&lt;br/&gt;</div><div class="line">    &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp</div><div class="line">    &lt;div&gt;&lt;a href=&quot;/add&quot; id=&quot;add&quot;&gt;EXTRA&lt;/a&gt;&lt;/div&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;Submit&quot; id=&quot;x&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">        var after_login=function(data,status)&#123;</div><div class="line">            if (status==&apos;success&apos;)&#123;</div><div class="line">                alert(data+&apos;--&apos;+status) ;</div><div class="line">            &#125;</div><div class="line">            else alert(&apos;login refused&apos;) ;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $(document).ready(function()&#123;</div><div class="line">            $(&quot;#x&quot;).click(function()&#123;</div><div class="line">                var name    =   $(&quot;#name&quot;).val() ;</div><div class="line">                var pwd     =   $(&quot;#pwd&quot;).val() ;</div><div class="line">                $.post(&apos;http://127.0.0.1:3000/login&apos;,</div><div class="line">                &#123;</div><div class="line">                    name    :   name ,</div><div class="line">                    pwd     :   pwd</div><div class="line">                &#125;,</div><div class="line">//                        function(data,status)&#123;</div><div class="line">//                            alert(data+&apos;--&apos;+status) ;</div><div class="line">//                        &#125;</div><div class="line">                        after_login</div><div class="line">                );</div><div class="line">//                $.get(&apos;add&apos;,function(data,status)&#123;</div><div class="line">//                    document.write(data) ;</div><div class="line">//                &#125;) ;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>next.html的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head lang=&quot;en&quot;&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;第二页面&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;This is an additional web page&lt;/h1&gt;</div><div class="line">&lt;p&gt;just for test&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。
    
    </summary>
    
      <category term="node" scheme="http://code.youmeek.com/categories/node/"/>
    
      <category term="前端" scheme="http://code.youmeek.com/categories/node/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node入门" scheme="http://code.youmeek.com/tags/Node%E5%85%A5%E9%97%A8/"/>
    
      <category term="前端开发" scheme="http://code.youmeek.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>迭代子模式</title>
    <link href="http://code.youmeek.com/2016/12/03/Iterate/"/>
    <id>http://code.youmeek.com/2016/12/03/Iterate/</id>
    <published>2016-12-02T16:00:00.000Z</published>
    <updated>2017-01-24T08:02:53.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>概念：在阎宏博士的《JAVA与模式》中关于迭代子模式的定义是这样的：迭代子模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。</p>
<h2 id="迭代子模式的意图及组成"><a href="#迭代子模式的意图及组成" class="headerlink" title="迭代子模式的意图及组成"></a>迭代子模式的意图及组成</h2><p>迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。</p>
<h3 id="白箱聚集与外禀迭代子"><a href="#白箱聚集与外禀迭代子" class="headerlink" title="白箱聚集与外禀迭代子"></a>白箱聚集与外禀迭代子</h3><p>如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。<br>如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示：<br><img src="http://img.blog.csdn.net/20161215214253592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。<br>一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。<br>　　因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。<br>　　一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示：<br><img src="http://img.blog.csdn.net/20161215214425814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="迭代子模式组成"><a href="#迭代子模式组成" class="headerlink" title="迭代子模式组成"></a>迭代子模式组成</h3><p>迭代子模式的组成主要有以下几个角色：<br><strong>抽象迭代子(Iterator)角色</strong>：此抽象角色定义出遍历元素所需的接口。<br><strong>具体迭代子(ConcreteIterator)角色</strong>：此角色实现了Iterator接口，并保持迭代过程中的游标位置。<br><strong>聚集(Aggregate)角色</strong>：此抽象角色给出创建迭代子(Iterator)对象的接口。<br><strong>具体聚集(ConcreteAggregate)角色</strong>：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。<br><strong>客户端(Client)角色</strong>：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。</p>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>抽象聚集角色类<br>这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class Aggregate &#123;  </div><div class="line">    /** </div><div class="line">     * 工厂方法，创建相应迭代子对象的接口 </div><div class="line">     */  </div><div class="line">    public abstract Iterator createIterator();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体聚集角色类<br>实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ConcreteAggregate extends Aggregate &#123;  </div><div class="line">      </div><div class="line">    private Object[] objArray = null;  </div><div class="line">    /** </div><div class="line">     * 构造方法，传入聚合对象的具体内容 </div><div class="line">     */  </div><div class="line">    public ConcreteAggregate(Object[] objArray)&#123;  </div><div class="line">        this.objArray = objArray;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    @Override  </div><div class="line">    public Iterator createIterator() &#123;  </div><div class="line">          </div><div class="line">        return new ConcreteIterator(this);  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 取值方法：向外界提供聚集元素 </div><div class="line">     */  </div><div class="line">    public Object getElement(int index)&#123;  </div><div class="line">          </div><div class="line">        if(index &lt; objArray.length)&#123;  </div><div class="line">            return objArray[index];  </div><div class="line">        &#125;else&#123;  </div><div class="line">            return null;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 取值方法：向外界提供聚集的大小 </div><div class="line">     */  </div><div class="line">    public int size()&#123;  </div><div class="line">        return objArray.length;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象迭代子角色类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;  </div><div class="line">    /** </div><div class="line">     * 迭代方法：移动到第一个元素 </div><div class="line">     */  </div><div class="line">    public void first();  </div><div class="line">    /** </div><div class="line">     * 迭代方法：移动到下一个元素 </div><div class="line">     */  </div><div class="line">    public void next();  </div><div class="line">    /** </div><div class="line">     * 迭代方法：是否为最后一个元素 </div><div class="line">     */  </div><div class="line">    public boolean isDone();  </div><div class="line">    /** </div><div class="line">     * 迭代方法：返还当前元素 </div><div class="line">     */  </div><div class="line">    public Object currentItem();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体迭代子角色类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class ConcreteIterator implements Iterator &#123;  </div><div class="line">    //持有被迭代的具体的聚合对象  </div><div class="line">    private ConcreteAggregate agg;  </div><div class="line">    //内部索引，记录当前迭代到的索引位置  </div><div class="line">    private int index = 0;  </div><div class="line">    //记录当前聚集对象的大小  </div><div class="line">    private int size = 0;  </div><div class="line">      </div><div class="line">    public ConcreteIterator(ConcreteAggregate agg)&#123;  </div><div class="line">        this.agg = agg;  </div><div class="line">        this.size = agg.size();  </div><div class="line">        index = 0;  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 迭代方法：返还当前元素 </div><div class="line">     */  </div><div class="line">    @Override  </div><div class="line">    public Object currentItem() &#123;  </div><div class="line">        return agg.getElement(index);  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 迭代方法：移动到第一个元素 </div><div class="line">     */  </div><div class="line">    @Override  </div><div class="line">    public void first() &#123;  </div><div class="line">          </div><div class="line">        index = 0;  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 迭代方法：是否为最后一个元素 </div><div class="line">     */  </div><div class="line">    @Override  </div><div class="line">    public boolean isDone() &#123;  </div><div class="line">        return (index &gt;= size);  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 迭代方法：移动到下一个元素 </div><div class="line">     */  </div><div class="line">    @Override  </div><div class="line">    public void next() &#123;  </div><div class="line">  </div><div class="line">        if(index &lt; size)  </div><div class="line">        &#123;  </div><div class="line">            index ++;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;  </div><div class="line">    public void operation()&#123;  </div><div class="line">        Object[] objArray = &#123;&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;&#125;;  </div><div class="line">        //创建聚合对象  </div><div class="line">        Aggregate agg = new ConcreteAggregate(objArray);  </div><div class="line">        //循环输出聚合对象中的值  </div><div class="line">        Iterator it = agg.createIterator();  </div><div class="line">        while(!it.isDone())&#123;  </div><div class="line">            System.out.println(it.currentItem());  </div><div class="line">            it.next();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">          </div><div class="line">        Client client = new Client();  </div><div class="line">        client.operation();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="黑箱聚集与内禀迭代子"><a href="#黑箱聚集与内禀迭代子" class="headerlink" title="黑箱聚集与内禀迭代子"></a>黑箱聚集与内禀迭代子</h3><p>如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的窄接口。<br>　　聚集对象为迭代子对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代子对象适当公开，以便迭代子对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代子对象进行这些工作，而不是直接操控聚集对象。<br><img src="http://img.blog.csdn.net/20161215215023673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在JAVA语言中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类。这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做黑箱实现方案。<br>　　由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做内禀迭代子（Intrinsic Iterator）。<br>　　为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代子接口的具体迭代子类，同时聚集并不向外界提供访问自己内部元素的方法。</p>
<h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><p>抽象聚集角色类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class Aggregate &#123;</div><div class="line">    /**</div><div class="line">     * 工厂方法，创建相应迭代子对象的接口</div><div class="line">     */</div><div class="line">    public abstract Iterator createIterator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>抽象迭代子角色类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface Iterator &#123;</div><div class="line">    /**</div><div class="line">     * 迭代方法：移动到第一个元素</div><div class="line">     */</div><div class="line">    public void first();</div><div class="line">    /**</div><div class="line">     * 迭代方法：移动到下一个元素</div><div class="line">     */</div><div class="line">    public void next();</div><div class="line">    /**</div><div class="line">     * 迭代方法：是否为最后一个元素</div><div class="line">     */</div><div class="line">    public boolean isDone();</div><div class="line">    /**</div><div class="line">     * 迭代方法：返还当前元素</div><div class="line">     */</div><div class="line">    public Object currentItem();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体聚集角色类，实现了抽象聚集角色所要求的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class ConcreteAggregate extends Aggregate &#123;</div><div class="line">    </div><div class="line">    private Object[] objArray = null;</div><div class="line">    /**</div><div class="line">     * 构造方法，传入聚合对象的具体内容</div><div class="line">     */</div><div class="line">    public ConcreteAggregate(Object[] objArray)&#123;</div><div class="line">        this.objArray = objArray;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public Iterator createIterator() &#123;</div><div class="line"></div><div class="line">        return new ConcreteIterator();</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 内部成员类，具体迭代子类</div><div class="line">     */</div><div class="line">    private class ConcreteIterator implements Iterator</div><div class="line">    &#123;</div><div class="line">        //内部索引，记录当前迭代到的索引位置</div><div class="line">        private int index = 0;</div><div class="line">        //记录当前聚集对象的大小</div><div class="line">        private int size = 0;</div><div class="line">        /**</div><div class="line">         * 构造函数</div><div class="line">         */</div><div class="line">        public ConcreteIterator()&#123;</div><div class="line">            </div><div class="line">            this.size = objArray.length;</div><div class="line">            index = 0;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * 迭代方法：返还当前元素</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public Object currentItem() &#123;</div><div class="line">            return objArray[index];</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * 迭代方法：移动到第一个元素</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void first() &#123;</div><div class="line">            </div><div class="line">            index = 0;</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * 迭代方法：是否为最后一个元素</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public boolean isDone() &#123;</div><div class="line">            return (index &gt;= size);</div><div class="line">        &#125;</div><div class="line">        /**</div><div class="line">         * 迭代方法：移动到下一个元素</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        public void next() &#123;</div><div class="line"></div><div class="line">            if(index &lt; size)</div><div class="line">            &#123;</div><div class="line">                index ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">    public void operation()&#123;</div><div class="line">        Object[] objArray = &#123;&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;&#125;;</div><div class="line">        //创建聚合对象</div><div class="line">        Aggregate agg = new ConcreteAggregate(objArray);</div><div class="line">        //循环输出聚合对象中的值</div><div class="line">        Iterator it = agg.createIterator();</div><div class="line">        while(!it.isDone())&#123;</div><div class="line">            System.out.println(it.currentItem());</div><div class="line">            it.next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        Client client = new Client();</div><div class="line">        client.operation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用迭代子模式的优点"><a href="#使用迭代子模式的优点" class="headerlink" title="使用迭代子模式的优点"></a>使用迭代子模式的优点</h2><p>　（1）迭代子模式简化了聚集的接口。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。<br>　　（2）每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。<br>　　（3）由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。</p>]]></content>
    
    <summary type="html">
    
      迭代子模式
    
    </summary>
    
      <category term="设计模式" scheme="http://code.youmeek.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="迭代子模式" scheme="http://code.youmeek.com/tags/%E8%BF%AD%E4%BB%A3%E5%AD%90%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://code.youmeek.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://code.youmeek.com/2016/12/01/robot/"/>
    <id>http://code.youmeek.com/2016/12/01/robot/</id>
    <published>2016-11-30T16:00:00.000Z</published>
    <updated>2017-01-24T08:02:37.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>什么是机器学习？<br>机器学习是英文名称Machine Learning(简称ML)的直译。机器学习涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。<br>相对于传统的计算机工作，我们给它一串指令，然后它遵照这个指令一步步执行下去即可。机器学习根本不接受你输入的指令，相反，它只接受你输入的数据!也就是说它某种意义上具有了我们人处理事情的能力。</p>
<h2 id="机器学习发展史"><a href="#机器学习发展史" class="headerlink" title="机器学习发展史"></a>机器学习发展史</h2><p>机器学习是人工智能研究较为年轻的分支，它的发展过程大体上可分为4个时期。<br>第一阶段是在20世纪50年代中叶到60年代中叶，属于热烈时期。<br>第二阶段是在20世纪60年代中叶至70年代中叶，被称为机器学习的冷静时期。<br>第三阶段是从20世纪70年代中叶至80年代中叶，称为复兴时期。<br>机器学习的最新阶段始于1986年。机器学习进入新阶段的重要表现在下列诸方面：<br>(1) 机器学习已成为新的边缘学科并在高校形成一门课程。它综合应用心理学、生物学和神经生理学以及数学、自动化和计算机科学形成机器学习理论基础。<br>(2) 结合各种学习方法，取长补短的多种形式的集成学习系统研究正在兴起。特别是连接学习符号学习的耦合可以更好地解决连续性信号处理中知识与技能的获取与求精问题而受到重视。<br>(3) 机器学习与人工智能各种基础问题的统一性观点正在形成。例如学习与问题求解结合进行、知识表达便于学习的观点产生了通用智能系统SOAR的组块学习。类比学习与问题求解结合的基于案例方法已成为经验学习的重要方向。<br>(4) 各种学习方法的应用范围不断扩大，一部分已形成商品。归纳学习的知识获取工具已在诊断分类型专家系统中广泛使用。连接学习在声图文识别中占优势。分析学习已用于设计综合型专家系统。遗传算法与强化学习在工程控制中有较好的应用前景。与符号系统耦合的神经网络连接学习将在企业的智能管理与智能机器人运动规划中发挥作用。<br>(5) 与机器学习有关的学术活动空前活跃。国际上除每年一次的机器学习研讨会外，还有计算机学习理论会议以及遗传算法会议。</p>
<h2 id="机器学习的范围"><a href="#机器学习的范围" class="headerlink" title="机器学习的范围"></a>机器学习的范围</h2><p>机器学习跟模式识别，统计学习，数据挖掘，计算机视觉，语音识别，自然语言处理等领域有着很深的联系。从范围上来说，机器学习跟模式识别，统计学习，数据挖掘是类似的，同时，机器学习与其他领域的处理技术的结合，形成了计算机视觉、语音识别、自然语言处理等交叉学科。因此，一般说数据挖掘时，可以等同于说机器学习。同时，我们平常所说的机器学习应用，应该是通用的，不仅仅局限在结构化数据，还有图像，音频等应用。</p>
<h3 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h3><p>模式识别=机器学习。两者的主要区别在于前者是从工业界发展起来的概念，后者则主要源自计算机学科。在著名的《Pattern Recognition And Machine Learning》这本书中，Christopher M. Bishop在开头是这样说的“模式识别源自工业界，而机器学习来自于计算机学科。不过，它们中的活动可以被视为同一个领域的两个方面，同时在过去的10年间，它们都有了长足的发展”。</p>
<h3 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h3><p>数据挖掘=机器学习+数据库，记得大学的最后一学期开了一门数据挖掘的课，何为数据挖掘，就是从海量的数据中挖掘出有用的数据，其实从某种意义上来说和大数据分析很像。数据挖掘通常与计算机科学有关，并通过统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等诸多方法来实现上述目标。</p>
<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><p>统计学习近似等于机器学习。统计学习是个与机器学习高度重叠的学科。因为机器学习中的大多数方法来自统计学，甚至可以认为，统计学的发展促进机器学习的繁荣昌盛。例如著名的支持向量机算法，就是源自统计学科。但是在某种程度上两者是有分别的，这个分别在于：统计学习者重点关注的是统计模型的发展与优化，偏数学，而机器学习者更关注的是能够解决问题，偏实践，因此机器学习研究者会重点研究学习算法在计算机上执行的效率与准确性的提升。</p>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>计算机视觉=图像处理+机器学习。图像处理技术用于将图像处理为适合进入机器学习模型中的输入，机器学习则负责从图像中识别出相关的模式。随着机器学习的新领域深度学习的发展，大大促进了计算机图像识别的效果，因此未来计算机视觉界的发展前景不可估量。</p>
<h3 id="语音识别"><a href="#语音识别" class="headerlink" title="语音识别"></a>语音识别</h3><p>语音识别=语音处理+机器学习。语音识别就是音频处理技术与机器学习的结合。语音识别技术一般不会单独使用，一般会结合自然语言处理的相关技术。目前的相关应用有苹果的语音助手siri，讯飞等国内很多的科技公司和机构。</p>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>自然语言处理=文本处理+机器学习。自然语言处理技术主要是让机器理解人类的语言的一门领域。在自然语言处理技术中，大量使用了编译原理相关的技术，例如词法分析，语法分析等等，除此之外，在理解这个层面，则使用了语义理解，机器学习等技术。</p>
<h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><h3 id="监督式学习"><a href="#监督式学习" class="headerlink" title="监督式学习"></a>监督式学习</h3><p>监督式学习算法包括一个目标变量（因变量）和用来预测目标变量的预测变量（自变量）。通过这些变量我们可以搭建一个模型，从而对于一个已知的预测变量值，我们可以得到对应的目标变量值。重复训练这个模型，直到它能在训练数据集上达到预定的准确度。 属于监督式学习的算法有：回归模型，决策树，随机森林，K邻近算法，逻辑回归等。</p>
<h3 id="无监督式学习"><a href="#无监督式学习" class="headerlink" title="无监督式学习"></a>无监督式学习</h3><p>与监督式学习不同的是，无监督学习中我们没有需要预测或估计的目标变量。无监督式学习是用来对总体对象进行分类的。它在根据某一指标将客户分类上有广泛应用。 属于无监督式学习的算法有：关联规则，K-means聚类算法等。</p>
<h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><p>常见的机器学习算法<br>以下是最常用的机器学习算法，大部分数据问题都可以通过它们解决：<br>1.线性回归 (Linear Regression)<br>2.逻辑回归 (Logistic Regression)<br>3.决策树 (Decision Tree)<br>4.支持向量机（SVM）<br>5.朴素贝叶斯 (Naive Bayes)<br>6.K邻近算法（KNN）<br>7.K-均值算法（K-means）<br>8.随机森林 (Random Forest)<br>9.降低维度算法（DimensionalityReduction Algorithms）<br>10.GradientBoost和Adaboost算法</p>
<h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><h3 id="基于学习策略的分类"><a href="#基于学习策略的分类" class="headerlink" title="基于学习策略的分类"></a>基于学习策略的分类</h3><p>学习策略是指学习过程中系统所采用的推理策略。一个学习系统总是由学习和环境两部分组成。由环境（如书本或教师）提供信息，学习部分则实现信息转换，用能够理解的形式记忆下来，并从中获取有用的信息。在学习过程中，学生（学习部分）使用的推理越少，他对教师（环境）的依赖就越大，教师的负担也就越重。学习策略的分类标准就是根据学生实现信息转换所需的推理多少和难易程度来分类的，依从简单到复杂，从少到多的次序分为以下六种基本类型：</p>
<h4 id="1）机械学习-Rote-learning"><a href="#1）机械学习-Rote-learning" class="headerlink" title="1）机械学习 (Rote learning)"></a>1）机械学习 (Rote learning)</h4><p>学习者无需任何推理或其它的知识转换，直接吸取环境所提供的信息。如塞缪尔的跳棋程序，纽厄尔和西蒙的LT系统。这类学习系统主要考虑的是如何索引存贮的知识并加以利用。系统的学习方法是直接通过事先编好、构造好的程序来学习，学习者不作任何工作，或者是通过直接接收既定的事实和数据进行学习，对输入信息不作任何的推理。</p>
<h4 id="2）示教学习-Learning-from-instruction或Learning-by-being-told"><a href="#2）示教学习-Learning-from-instruction或Learning-by-being-told" class="headerlink" title="2）示教学习 (Learning from instruction或Learning by being told)"></a>2）示教学习 (Learning from instruction或Learning by being told)</h4><p>学生从环境（教师或其它信息源如教科书等）获取信息，把知识转换成内部可使用的表示形式，并将新的知识和原有知识有机地结合为一体。所以要求学生有一定程度的推理能力，但环境仍要做大量的工作。教师以某种形式提出和组织知识，以使学生拥有的知识可以不断地增加。这种学习方法和人类社会的学校教学方式相似，学习的任务就是建立一个系统，使它能接受教导和建议，并有效地存贮和应用学到的知识。不少专家系统在建立知识库时使用这种方法去实现知识获取。示教学习的一个典型应用例是FOO程序。</p>
<h4 id="3）演绎学习-Learning-by-deduction"><a href="#3）演绎学习-Learning-by-deduction" class="headerlink" title="3）演绎学习 (Learning by deduction)"></a>3）演绎学习 (Learning by deduction)</h4><p>学生所用的推理形式为演绎推理。推理从公理出发，经过逻辑变换推导出结论。这种推理是”保真”变换和特化(specialization)的过程，使学生在推理过程中可以获取有用的知识。这种学习方法包含宏操作(macro-operation)学习、知识编辑和组块(Chunking)技术。演绎推理的逆过程是归纳推理。</p>
<h4 id="4）类比学习-Learning-by-analogy"><a href="#4）类比学习-Learning-by-analogy" class="headerlink" title="4）类比学习 (Learning by analogy)"></a>4）类比学习 (Learning by analogy)</h4><p>利用二个不同领域（源域、目标域）中的知识相似性，可以通过类比，从源域的知识（包括相似的特征和其它性质）推导出目标域的相应知识，从而实现学习。类比学习系统可以使一个已有的计算机应用系统转变为适应于新的领域，来完成原先没有设计的相类似的功能。<br>类比学习需要比上述三种学习方式更多的推理。它一般要求先从知识源（源域）中检索出可用的知识，再将其转换成新的形式，用到新的状况（目标域）中去。类比学习在人类科学技术发展史上起着重要作用，许多科学发现就是通过类比得到的。例如著名的卢瑟福类比就是通过将原子结构（目标域）同太阳系（源域）作类比，揭示了原子结构的奥秘。</p>
<h4 id="5）基于解释的学习-Explanation-based-learning-EBL"><a href="#5）基于解释的学习-Explanation-based-learning-EBL" class="headerlink" title="5）基于解释的学习 (Explanation-based learning, EBL)"></a>5）基于解释的学习 (Explanation-based learning, EBL)</h4><p>学生根据教师提供的目标概念、该概念的一个例子、领域理论及可操作准则，首先构造一个解释来说明为什该例子满足目标概念，然后将解释推广为目标概念的一个满足可操作准则的充分条件。EBL已被广泛应用于知识库求精和改善系统的性能。<br>著名的EBL系统有迪乔恩（G.DeJong）的GENESIS,米切尔（T.Mitchell）的LEXII和LEAP, 以及明顿（S.Minton）等的PRODIGY。</p>
<h4 id="6）归纳学习-Learning-from-induction"><a href="#6）归纳学习-Learning-from-induction" class="headerlink" title="6）归纳学习 (Learning from induction)"></a>6）归纳学习 (Learning from induction)</h4><p>归纳学习是由教师或环境提供某概念的一些实例或反例，让学生通过归纳推理得出该概念的一般描述。这种学习的推理工作量远多于示教学习和演绎学习，因为环境并不提供一般性概念描述（如公理）。从某种程度上说，归纳学习的推理量也比类比学习大，因为没有一个类似的概念可以作为”源概念”加以取用。归纳学习是最基本的，发展也较为成熟的学习方法，在人工智能领域中已经得到广泛的研究和应用。</p>
<h3 id="基于所获取知识的表示形式分类"><a href="#基于所获取知识的表示形式分类" class="headerlink" title="基于所获取知识的表示形式分类　"></a>基于所获取知识的表示形式分类　</h3><p>学习系统获取的知识可能有：行为规则、物理对象的描述、问题求解策略、各种分类及其它用于任务实现的知识类型。<br>对于学习中获取的知识，主要有以下一些表示形式：</p>
<h4 id="1）代数表达式参数"><a href="#1）代数表达式参数" class="headerlink" title="1）代数表达式参数"></a>1）代数表达式参数</h4><p>学习的目标是调节一个固定函数形式的代数表达式参数或系数来达到一个理想的性能。</p>
<h4 id="2）决策树"><a href="#2）决策树" class="headerlink" title="2）决策树"></a>2）决策树</h4><p>用决策树来划分物体的类属，树中每一内部节点对应一个物体属性，而每一边对应于这些属性的可选值，树的叶节点则对应于物体的每个基本分类。</p>
<h4 id="3）形式文法"><a href="#3）形式文法" class="headerlink" title="3）形式文法"></a>3）形式文法</h4><p>在识别一个特定语言的学习中，通过对该语言的一系列表达式进行归纳，形成该语言的形式文法。</p>
<h4 id="4）产生式规则"><a href="#4）产生式规则" class="headerlink" title="4）产生式规则"></a>4）产生式规则</h4><p>产生式规则表示为条件—动作对，已被极为广泛地使用。学习系统中的学习行为主要是：生成、泛化、特化（Specialization）或合成产生式规则。</p>
<h4 id="5）形式逻辑表达式"><a href="#5）形式逻辑表达式" class="headerlink" title="5）形式逻辑表达式"></a>5）形式逻辑表达式</h4><p>形式逻辑表达式的基本成分是命题、谓词、变量、约束变量范围的语句，及嵌入的逻辑表达式。</p>
<h4 id="6）图和网络"><a href="#6）图和网络" class="headerlink" title="6）图和网络"></a>6）图和网络</h4><p>有的系统采用图匹配和图转换方案来有效地比较和索引知识。</p>
<h4 id="7）框架和模式（schema）"><a href="#7）框架和模式（schema）" class="headerlink" title="7）框架和模式（schema）"></a>7）框架和模式（schema）</h4><p>每个框架包含一组槽，用于描述事物（概念和个体）的各个方面。</p>
<h4 id="8）计算机程序和其它的过程编码"><a href="#8）计算机程序和其它的过程编码" class="headerlink" title="8）计算机程序和其它的过程编码"></a>8）计算机程序和其它的过程编码</h4><p>获取这种形式的知识，目的在于取得一种能实现特定过程的能力，而不是为了推断该过程的内部结构。</p>
<h4 id="9）神经网络"><a href="#9）神经网络" class="headerlink" title="9）神经网络"></a>9）神经网络</h4><p>这主要用在联接学习中。学习所获取的知识，最后归纳为一个神经网络。</p>
<h4 id="10）多种表示形式的组合"><a href="#10）多种表示形式的组合" class="headerlink" title="10）多种表示形式的组合"></a>10）多种表示形式的组合</h4><p>根据表示的精细程度，可将知识表示形式分为两大类：泛化程度高的粗粒度符号表示、??泛化程度低的精粒度亚符号(sub-symbolic)表示。像决策树、形式文法、产生式规则、形式逻辑表达式、框架和模式等属于符号表示类；而代数表达式参数、图和网络、神经网络等则属亚符号表示类。</p>
<h3 id="按应用领域分类"><a href="#按应用领域分类" class="headerlink" title="按应用领域分类　"></a>按应用领域分类　</h3><p>最主要的应用领域有：专家系统、认知模拟、规划和问题求解、数据挖掘、网络信息服务、图象识别、故障诊断、自然语言理解、机器人和博弈等领域。<br>从机器学习的执行部分所反映的任务类型上看，大部分的应用研究领域基本上集中于以下两个范畴：分类和问题求解。<br>（1）分类任务要求系统依据已知的分类知识对输入的未知模式（该模式的描述）作分析，以确定输入模式的类属。相应的学习目标就是学习用于分类的准则（如分类规则）。<br>（2）问题求解任务要求对于给定的目标状态,??寻找一个将当前状态转换为目标状态的动作序列；机器学习在这一领域的研究工作大部分集中于通过学习来获取能提高问题求解效率的知识（如搜索控制知识，启发式知识等）。</p>
<h3 id="综合分类"><a href="#综合分类" class="headerlink" title="综合分类"></a>综合分类</h3><h4 id="1）经验性归纳学习-empirical-inductive-learning"><a href="#1）经验性归纳学习-empirical-inductive-learning" class="headerlink" title="1）经验性归纳学习 (empirical inductive learning)"></a>1）经验性归纳学习 (empirical inductive learning)</h4><p>经验性归纳学习采用一些数据密集的经验方法（如版本空间法、ID3法，定律发现方法）对例子进行归纳学习。其例子和学习结果一般都采用属性、谓词、关系等符号表示。它相当于基于学习策略分类中的归纳学习，但扣除联接学习、遗传算法、加强学习的部分。</p>
<h4 id="2）分析学习（analytic-learning）"><a href="#2）分析学习（analytic-learning）" class="headerlink" title="2）分析学习（analytic learning）"></a>2）分析学习（analytic learning）</h4><p>分析学习方法是从一个或少数几个实例出发，运用领域知识进行分析。其主要特征为：<br>·推理策略主要是演绎，而非归纳；<br>·使用过去的问题求解经验（实例）指导新的问题求解，或产生能更有效地运用领域知识的搜索控制规则。<br>分析学习的目标是改善系统的性能，而不是新的概念描述。分析学习包括应用解释学习、演绎学习、多级结构组块以及宏操作学习等技术。</p>
<h4 id="3）类比学习"><a href="#3）类比学习" class="headerlink" title="3）类比学习"></a>3）类比学习</h4><p>它相当于基于学习策略分类中的类比学习。在这一类型的学习中比较引人注目的研究是通过与过去经历的具体事例作类比来学习，称为基于范例的学习(case_based learning)，或简称范例学习。</p>
<h2 id="机器学习代码示例"><a href="#机器学习代码示例" class="headerlink" title="机器学习代码示例"></a>机器学习代码示例</h2><p>机器学习语音设计到pytho和R等最新语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">//在gcc-4.7.2下编译通过。</div><div class="line">//命令行：g++-Wall-ansi-O2test.cpp-otest</div><div class="line">#include&lt;iostream&gt;</div><div class="line">usingnamespacestd;</div><div class="line">voidinput(int&amp;oper,constboolmeth)</div><div class="line">&#123;</div><div class="line">//meth为true则只判断1，为false则判断1或0</div><div class="line">while(true)</div><div class="line">&#123;</div><div class="line">cin&gt;&gt;oper;</div><div class="line">if(meth&amp;&amp;oper==1)</div><div class="line">break;</div><div class="line">elseif(oper==0||oper==1)</div><div class="line">break;</div><div class="line">cout&lt;&lt;&quot;输入错误，请重新输入。&quot;&lt;&lt;endl;//判断参数</div><div class="line">cin.sync();//避免极端输入导致死循环</div><div class="line">cin.clear();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">intmain(void)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;1+1=2吗？那要看您怎么教我了，不要惊讶我会学习的&quot;&lt;&lt;endl;</div><div class="line">intladd,radd,aprs,rcnt(0),wcnt(0);//定义输入与结果，正确次数与错误次数</div><div class="line">cout&lt;&lt;&quot;开始学习……&quot;&lt;&lt;endl;</div><div class="line">for(inti(0);i!=10;++i)</div><div class="line">&#123;</div><div class="line">cout&lt;&lt;&quot;参数1（必须是1）：&quot;&lt;&lt;flush;//提示输入参数</div><div class="line">input(ladd,true);</div><div class="line">cout&lt;&lt;&quot;参数2（必须是1）：&quot;&lt;&lt;flush;</div><div class="line">input(radd,true);</div><div class="line">cout&lt;&lt;&quot;结果：&quot;&lt;&lt;(ladd+radd)&lt;&lt;endl;//输出结果</div><div class="line">cout&lt;&lt;&quot;您对这满意吗（满意输入1，不满意输入0）：&quot;&lt;&lt;flush;//评价等级</div><div class="line">input(aprs,false);</div><div class="line">if(aprs)//判断用户评价</div><div class="line">++rcnt;</div><div class="line">else</div><div class="line">++wcnt;</div><div class="line">cout&lt;&lt;&quot;正确次数：&quot;&lt;&lt;rcnt&lt;&lt;&quot;错误次数：&quot;&lt;&lt;wcnt&lt;&lt;endl;//错误次数</div><div class="line">&#125;</div><div class="line">if(rcnt&gt;wcnt)//判断学习结果</div><div class="line">cout&lt;&lt;&quot;主人告诉我1+1=2。&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">if(rcnt&lt;wcnt)</div><div class="line">cout&lt;&lt;&quot;主人告诉我1+1!=2。&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">cout&lt;&lt;&quot;我不明白主人是什么意思。&quot;&lt;&lt;endl;</div><div class="line">intterm;//退出部分</div><div class="line">cout&lt;&lt;&quot;您对我的表现满意吗？满意请输入1不满意请输入0：&quot;&lt;&lt;flush;</div><div class="line">input(term,false);</div><div class="line">if(term)</div><div class="line">cout&lt;&lt;&quot;谢谢我会继续努力学习&quot;&lt;&lt;endl;</div><div class="line">else</div><div class="line">cout&lt;&lt;&quot;谢谢我会继续努力学习D&quot;&lt;&lt;endl;</div><div class="line">//cin&gt;&gt;term;//在Windows上测试时启用</div><div class="line">return0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      机器学习
    
    </summary>
    
      <category term="大数据" scheme="http://code.youmeek.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://code.youmeek.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="机器学习" scheme="http://code.youmeek.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>webpack+react环境搭建</title>
    <link href="http://code.youmeek.com/2016/11/05/webpack+react%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://code.youmeek.com/2016/11/05/webpack+react环境搭建/</id>
    <published>2016-11-04T16:00:00.000Z</published>
    <updated>2017-01-25T03:02:38.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道前端的框架纷繁复杂，各有各的优点。而我们选择使用React作为开发框架的时候，往往会选择Webpack+Babel+React来开始我们的项目。之前也讲过其他的前端框架，如<a href="http://blog.csdn.net/xiangzhihong8/article/details/53993980" target="_blank" rel="external"> gulp+webpack</a>，准确的说这不是一个框架，只是项目组织的形式而已。</p>
<h1 id="Webpack-Babel-React环境搭建"><a href="#Webpack-Babel-React环境搭建" class="headerlink" title="Webpack+Babel+React环境搭建"></a>Webpack+Babel+React环境搭建</h1><h2 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h2><p>关于Webpack的介绍这里不讲解，大家可以看之前的讲解<a href="http://blog.csdn.net/xiangzhihong8/article/details/53993980" target="_blank" rel="external">webpack介绍</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack -g</div></pre></td></tr></table></figure>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>创建一个名叫learn-webpack项目，并进去项目目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir learn-webpack </div><div class="line">cd learn-webpack</div></pre></td></tr></table></figure></p>
<p><img src="http://img.blog.csdn.net/20170104224231893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>接下来我们来创建2个文件:app.js和index.html，我们在也没上输出一个”Hello World”，<br>app.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.querySelector(&apos;#app&apos;).innerHTML = &apos;Hello World!&apos;;</div></pre></td></tr></table></figure></p>
<p>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;Learn-webpack&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>然后在终端执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack ./app.js ./dist/bundle.js</div></pre></td></tr></table></figure>
<p>最后执行启动本地的http服务，我们这里用python：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m SimpleHTTPServer</div></pre></td></tr></table></figure>
<p>然后我们访问：<a href="http://localhost:8000就可以看到效果了。" target="_blank" rel="external">http://localhost:8000就可以看到效果了。</a></p>
<h2 id="webpack文件配置"><a href="#webpack文件配置" class="headerlink" title="webpack文件配置"></a>webpack文件配置</h2><p>实际上每个项目下都应该包含一个webpack.config.js，用来告诉Webpack需要做些什么，这个我们之前文章也说过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们在终端运行命令，看看是不是和之前输入 webpack ./app.js ./dist/bundle.js 的打包编译结果一样呢，答案是肯定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack</div></pre></td></tr></table></figure>
<p>注：<br><strong>entry：指定打包的入口文件</strong></p>
<ul>
<li>单个文件打包为单个输出文件，直接写该文件的名字，例如：entry:”main.js”</li>
<li>多个文件打包为单个输出文件，将文件名放进一个数组，例如：entry:[‘main.js’,’xx.js’]</li>
<li>多个文件打包为多个输出文件，将文件名放入一个键字对，例如：entry: {a:’main.js’,b:’xx.js’}<br><strong>output：配置打包结果</strong><br>path为定义输出文件夹，filename为打包结果文件的名称，如果指定打包入口文件为上面的1、2种情况，filename里面直接跟你想输出的文件名。若为第3种情况filename里面需写成[name].文件名.js，filename里面的[name]为entry中的键。<h3 id="监听变化自动打包"><a href="#监听变化自动打包" class="headerlink" title="监听变化自动打包"></a>监听变化自动打包</h3>当我们在不停的对代码进行变动的时候，为了不修改一次然后又手动去进行打包一次，可以使用webpack的watch功能。这也算是webpack的一个黑科技，以前做后端的时候必须重新部署，这个是很蛋疼的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --watch 或者 webpack -w</div></pre></td></tr></table></figure>
<p>或者我们可以直接在配置代码里面把watch设置为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line">  watch: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h2><p>Babel 是一个 JavaScript 编译器。使用它可以将ES6的语法转换为ES5的语法，以便在现在有的环境执行之前的代码。<br>首先安装basel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install webpack babel-loader babel-core babel-preset-es2015 --save-dev</div></pre></td></tr></table></figure>
<p>执行安装完成后需要将之前的webpack.config.js修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry: &quot;./app.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname+&quot;/dist&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: /\.jsx?$/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        exclude: /node_modules/,</div><div class="line">        query: &#123;</div><div class="line">          presets: [&apos;es2015&apos;]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    extensions: [&apos;&apos;,&apos;.coffee&apos;,&apos;.js&apos;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在就能在文件里面以ES6的语法进行代码编写，如在app.js加入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var func = str =&gt; &#123;</div><div class="line">  console.log(str);</div><div class="line">&#125;;</div><div class="line">func(&apos;Hello Babel!&apos;);</div></pre></td></tr></table></figure>
<p>我们再次运行，如果看到输出，就说明配置成功了。这里有关Loader的知识和配置就不讲究了，大家可以网上补补。</p>
<h2 id="与React结合"><a href="#与React结合" class="headerlink" title="与React结合"></a>与React结合</h2><p>终端输入以下代码对react和react-dom进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react react-dom --save</div></pre></td></tr></table></figure>
<p>安装Babel针对React的预设插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-preset-react --save-dev</div></pre></td></tr></table></figure>
<p>由于我们增加了react的预设插件，所以需要对webpack.config.js进行修改。将module -&gt; loaders下面的query修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">query: &#123;</div><div class="line">    presets: [&apos;es2015&apos;,&apos;react&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们创建一个hello.js.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import React from &quot;react&quot;;</div><div class="line"></div><div class="line">class Hello extends React.Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div&gt;</div><div class="line">          Hello, World!</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Hello;</div></pre></td></tr></table></figure>
<p>在app.js做一下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import React from &quot;react&quot;;</div><div class="line">import ReactDOM from &quot;react-dom&quot;;</div><div class="line">import Hello from &quot;./hello&quot;;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Hello /&gt;,</div><div class="line">  document.querySelector(&apos;#app&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>哈哈哈，这里如果大家做过React Native的，这里是不是感觉很亲切，只不过React Native还是用的npm在做管理。我们同样启动服务在看看，如果看到Hello World!就说明环境配置成功。</p>]]></content>
    
    <summary type="html">
    
      我们知道前端的框架纷繁复杂，各有各的优点。而我们选择使用React作为开发框架的时候，往往会选择Webpack+Babel+React来开始我们的项目。
    
    </summary>
    
      <category term="前端" scheme="http://code.youmeek.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端开发" scheme="http://code.youmeek.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="react" scheme="http://code.youmeek.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Node入门</title>
    <link href="http://code.youmeek.com/2016/11/05/visitor/"/>
    <id>http://code.youmeek.com/2016/11/05/visitor/</id>
    <published>2016-11-04T16:00:00.000Z</published>
    <updated>2017-01-24T08:06:38.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h2><p>Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。<br>Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。</p>
<h2 id="什么是v8引擎"><a href="#什么是v8引擎" class="headerlink" title="什么是v8引擎"></a>什么是v8引擎</h2><p>V8 JavaScript 引擎是 Google 用于其 Chrome 浏览器的底层 JavaScript 引擎。很少有人考虑 JavaScript 在客户机上实际做了些什么？实际上，JavaScript 引擎负责解释并执行代码。Google 使用 V8 创建了一个用 C++ 编写的超快解释器，该解释器拥有另一个独特特征；您可以下载该引擎并将其嵌入任何 应用程序。V8 JavaScript 引擎并不仅限于在一个浏览器中运行。因此，Node 实际上会使用 Google 编写的 V8 JavaScript 引擎，并将其重建为可在服务器上使用。</p>
<h2 id="Node-js的作用"><a href="#Node-js的作用" class="headerlink" title="Node.js的作用"></a>Node.js的作用</h2><p>Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java™ 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。<br>而Node的出现就是为了解决这个问题：更改连接到服务器的方式。在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。</p>
<h2 id="Node-js能做什么"><a href="#Node-js能做什么" class="headerlink" title="Node.js能做什么"></a>Node.js能做什么</h2><p>借用一句经典的描述Node.js的话:正如 JavaScript 为客户端而生，Node.js 为网络而生。<br>使用Node.js，你可以轻易的实现：</p>
<ul>
<li>具有复杂逻辑的网站；</li>
<li>基于社交网络的大规模 Web 应用；</li>
<li>Web Socket 服务器；</li>
<li>TCP/UDP 套接字应用程序；</li>
<li>命令行工具；</li>
<li>交互式终端程序；</li>
<li>带有图形用户界面的本地应用程序；</li>
<li>单元测试工具；</li>
<li>客户端 JavaScript 编译器。</li>
</ul>
<h2 id="什么是事件驱动编程"><a href="#什么是事件驱动编程" class="headerlink" title="什么是事件驱动编程"></a>什么是事件驱动编程</h2><p>在我们使用Java，PHP等语言实现编程的时候，我们面向对象编程是完美的编程设计，这使得他们对其他编程方法不屑一顾。却不知大名鼎鼎Node使用的却是事件驱动编程的思想。那什么是事件驱动编程。<br><strong>事件驱动编程，为需要处理的事件编写相应的事件处理程序。代码在事件发生时执行。</strong><br>为需要处理的事件编写相应的事件处理程序。要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu。<br>来看一张简单的事件驱动模型（uml）：</p>
<p><img src="http://img.blog.csdn.net/20161231115520916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。</p>
<ul>
<li>事件源：产生事件的地方(html元素)</li>
<li>事件：点击/鼠标操作/键盘操作等等</li>
<li>事件对象：当某个事件发生时，可能会产生一个事件对象，该时间对象会封装好该时间的信息，传递给事件处理程序</li>
<li>事件处理程序：响应用户事件的代码<br>其实我们使用的window系统也算得上是事件驱动了。我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt; </div><div class="line">   &lt;head&gt; </div><div class="line">   &lt;script&gt; </div><div class="line">   function test1(e)&#123; </div><div class="line">     window.alert(&quot;x=&quot;+e.clientX+&quot;y=&quot;+e.clientY); </div><div class="line">   &#125; </div><div class="line">   &lt;/script&gt; </div><div class="line">   &lt;/head&gt; </div><div class="line">   &lt;body onmousedown=&quot;test1(event)&quot;&gt; </div><div class="line">   &lt;/body&gt; </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h1 id="Node-js运行原理分析"><a href="#Node-js运行原理分析" class="headerlink" title="Node.js运行原理分析"></a>Node.js运行原理分析</h1><p>当我们搜索Node.js时，夺眶而出的关键字就是 “单线程，异步I/O，事件驱动”，应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务。<br>    所以I/O才是应用程序的瓶颈所在，在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。<br>     但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但操作系统在内核切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。<br> 那么是否可以另辟蹊径呢？！我们先来看看单线程，《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图：<br> <img src="http://img.blog.csdn.net/20161231120417621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。<br> I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。<br> 在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。</p>
<h1 id="Node-js的简单实践"><a href="#Node-js的简单实践" class="headerlink" title="Node.js的简单实践"></a>Node.js的简单实践</h1><p> 关于node的环境搭建这里就不说明了<a href="http://blog.csdn.net/xiangzhihong8/article/details/52842061" target="_blank" rel="external">node入门</a>。这里为了方便大家理解，我们写一个简单的登录实例。<br> 这里为了方便前端小白的理解，新增一个小节，如何使用Node搭建一个新的项目。</p>
<h2 id="使用Node创建项目"><a href="#使用Node创建项目" class="headerlink" title="使用Node创建项目"></a>使用Node创建项目</h2><p> 安装Express</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g express  </div><div class="line">npm install -g express-generator</div></pre></td></tr></table></figure>
<p>新建项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">express -t ejs newsproject</div></pre></td></tr></table></figure></p>
<p>按照提示进入项目目录，运行npm安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd newsprojec</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>运行项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node app.js</div></pre></td></tr></table></figure>
<p>浏览器访问:<a href="http://127.0.0.1:3000/即可见nodejs站点页面即可。" target="_blank" rel="external">http://127.0.0.1:3000/即可见nodejs站点页面即可。</a><br>接下来我们写一个简单的例子，来看一下效果图：<br><img src="http://img.blog.csdn.net/20161231215128577?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br> 整个目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">根目录--------------</div><div class="line">    |-package.json</div><div class="line">    |-test.js</div><div class="line">    |-public</div><div class="line">        |-main.html</div><div class="line">        |-next.html</div></pre></td></tr></table></figure></p>
<p>整个目录包含三个文件，test.js（作为控制文件）、main.html和next.html作为页面的显示文件。<br>来看一下代码：<br>test.js（作为控制文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// file name :test.js</div><div class="line">var express             = require(&apos;express&apos;);</div><div class="line">var app                 = express();</div><div class="line">var bodyParse           = require(&apos;body-parser&apos;)</div><div class="line">var cookieParser        = require(&apos;cookie-parser&apos;) ;</div><div class="line">app.use(cookieParser()) ;</div><div class="line">app.use(bodyParse.urlencoded(&#123;extended:false&#125;)) ;</div><div class="line"></div><div class="line">// 处理根目录的get请求</div><div class="line">app.get(&apos;/&apos;,function(req,res)&#123;</div><div class="line">    res.sendfile(&apos;public/main.html&apos;) ;</div><div class="line">    console.log(&apos;main page is required &apos;);</div><div class="line">&#125;) ;</div><div class="line"></div><div class="line">// 处理/login的get请求</div><div class="line">app.get(&apos;/add&apos;, function (req,res) &#123;</div><div class="line">    res.sendfile(&apos;public/add.html&apos;) ;</div><div class="line">    console.log(&apos;add page is required &apos;) ;</div><div class="line">&#125;) ;</div><div class="line"></div><div class="line">// 处理/login的post请求</div><div class="line">app.post(&apos;/login&apos;,function(req,res)&#123;</div><div class="line">    name=req.body.name ;</div><div class="line">    pwd=req.body.pwd   ;</div><div class="line">    console.log(name+&apos;--&apos;+pwd) ;</div><div class="line">    res.status(200).send(name+&apos;--&apos;+pwd) ;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 监听3000端口</div><div class="line">var server=app.listen(3000) ;</div></pre></td></tr></table></figure>
<p>main.html的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://fonts.useso.com/css?family=Tangerine|Inconsolata|Droid+Sans&quot;&gt;</div><div class="line"></div><div class="line">    &lt;style&gt;</div><div class="line">        div#test&#123;</div><div class="line">            font-family: &apos;Tangerine&apos;,serif;</div><div class="line">            font-size: 48px;</div><div class="line">        &#125;</div><div class="line">        p#link1&#123;</div><div class="line">            font-family: &apos;Tangerine&apos;,serif;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/style&gt;</div><div class="line"></div><div class="line">    &lt;script src=&quot;//cdn.bootcss.com/jquery/2.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;test&quot;&gt;</div><div class="line">    &lt;h1&gt;Main Page&lt;/h1&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;p&gt;Register &amp; Login&lt;/p&gt;</div><div class="line">&lt;form action=&quot;test.jsp&quot; method=&quot;post&quot;&gt;</div><div class="line">    账号 :</div><div class="line">    &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt;</div><div class="line">    &lt;br/&gt;&lt;br/&gt;</div><div class="line">    密码 :</div><div class="line">    &lt;input type=&quot;text&quot; id=&quot;pwd&quot; /&gt;</div><div class="line">    &lt;br/&gt;&lt;br/&gt;</div><div class="line">    &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp</div><div class="line">    &lt;div&gt;&lt;a href=&quot;/add&quot; id=&quot;add&quot;&gt;EXTRA&lt;/a&gt;&lt;/div&gt;</div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;Submit&quot; id=&quot;x&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">        var after_login=function(data,status)&#123;</div><div class="line">            if (status==&apos;success&apos;)&#123;</div><div class="line">                alert(data+&apos;--&apos;+status) ;</div><div class="line">            &#125;</div><div class="line">            else alert(&apos;login refused&apos;) ;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $(document).ready(function()&#123;</div><div class="line">            $(&quot;#x&quot;).click(function()&#123;</div><div class="line">                var name    =   $(&quot;#name&quot;).val() ;</div><div class="line">                var pwd     =   $(&quot;#pwd&quot;).val() ;</div><div class="line">                $.post(&apos;http://127.0.0.1:3000/login&apos;,</div><div class="line">                &#123;</div><div class="line">                    name    :   name ,</div><div class="line">                    pwd     :   pwd</div><div class="line">                &#125;,</div><div class="line">//                        function(data,status)&#123;</div><div class="line">//                            alert(data+&apos;--&apos;+status) ;</div><div class="line">//                        &#125;</div><div class="line">                        after_login</div><div class="line">                );</div><div class="line">//                $.get(&apos;add&apos;,function(data,status)&#123;</div><div class="line">//                    document.write(data) ;</div><div class="line">//                &#125;) ;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>next.html的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head lang=&quot;en&quot;&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;第二页面&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;This is an additional web page&lt;/h1&gt;</div><div class="line">&lt;p&gt;just for test&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Node入门
    
    </summary>
    
      <category term="前端" scheme="http://code.youmeek.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node入门" scheme="http://code.youmeek.com/tags/Node%E5%85%A5%E9%97%A8/"/>
    
      <category term="前端开发" scheme="http://code.youmeek.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>刷博客等流量</title>
    <link href="http://code.youmeek.com/2016/10/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://code.youmeek.com/2016/10/05/微信小程序/</id>
    <published>2016-10-04T16:00:00.000Z</published>
    <updated>2017-01-24T08:22:19.211Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们不建议刷流量，这里只是提供机械技术上的实现</p>
<p>-访客数量与ip无关，与cookie关，它对每个访问者给一个特定的cookie<br>//就是说，只要清除cookie再刷新就ok了<br>-刷新频率不能太快，太快会被记录。</p>
<p>方法一</p>
<p>手动清除浏览器cookie再刷新</p>
<p>方法二</p>
<p>使用wap浏览器<br><a href="http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54647581#" target="_blank" rel="external">http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54647581#</a><br>然后输入你要刷的链接<br>这里写图片描述<br>然后设置，取消cookies，勾上局部刷新<br>这里写图片描述</p>
<p>然后设置定时刷新<br>这里写图片描述</p>
<p>方法三</p>
<p>利用Python2.7自己写一个小程序</p>
<p>import time<br>import urllib<br>import urllib2</p>
<p>url = ‘<a href="http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54632384#" target="_blank" rel="external">http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54632384#</a>‘</p>
<p>user_agent = ‘Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)’<br>values = {‘name’: ‘WHY’,<br>          ‘location’: ‘SDU’,<br>          ‘language’: ‘Python’}</p>
<p>headers = {‘User-Agent’: user_agent}<br>data = urllib.urlencode(values)<br>req = urllib2.Request(url, data, headers)<br>cnt = 1<br>while cnt &lt;= 10000:<br>    response = urllib2.urlopen(req)<br>    print cnt<br>    cnt += 1<br>    time.sleep(1.0)<br>执行结果<br>这里写图片描述</p>
<p>方法四</p>
<p>这是方法三的升级，我们可以把Python代码交给Linux服务器去执行。<br>我使用的是openshift 免费空间，它空间很强，简直就是一个vps啊，可以shh链接，类linux操作。有兴趣的自己去申请一个，申请过程这里就不写了。</p>
<p>我们把方法三的代码保存为 work.py<br>然后让程序一直在后台跑就达到我们的目的了。执行命令：<br>nohup python work.py &amp;</p>
<p>这里写图片描述</p>
<p>最后结果</p>]]></content>
    
    <summary type="html">
    
      如何刷流量，不建议，没什么意义
    
    </summary>
    
      <category term="博客" scheme="http://code.youmeek.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://code.youmeek.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="流量" scheme="http://code.youmeek.com/tags/%E6%B5%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>刷博客等流量</title>
    <link href="http://code.youmeek.com/2016/10/05/%E5%88%B7%E6%B5%81%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://code.youmeek.com/2016/10/05/刷流量的几种方法/</id>
    <published>2016-10-04T16:00:00.000Z</published>
    <updated>2017-01-24T08:22:19.211Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们不建议刷流量，这里只是提供机械技术上的实现</p>
<p>-访客数量与ip无关，与cookie关，它对每个访问者给一个特定的cookie<br>//就是说，只要清除cookie再刷新就ok了<br>-刷新频率不能太快，太快会被记录。</p>
<p>方法一</p>
<p>手动清除浏览器cookie再刷新</p>
<p>方法二</p>
<p>使用wap浏览器<br><a href="http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54647581#" target="_blank" rel="external">http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54647581#</a><br>然后输入你要刷的链接<br>这里写图片描述<br>然后设置，取消cookies，勾上局部刷新<br>这里写图片描述</p>
<p>然后设置定时刷新<br>这里写图片描述</p>
<p>方法三</p>
<p>利用Python2.7自己写一个小程序</p>
<p>import time<br>import urllib<br>import urllib2</p>
<p>url = ‘<a href="http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54632384#" target="_blank" rel="external">http://www.pctowap.com/air/m.blog.csdn.net/article/details?id=54632384#</a>‘</p>
<p>user_agent = ‘Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)’<br>values = {‘name’: ‘WHY’,<br>          ‘location’: ‘SDU’,<br>          ‘language’: ‘Python’}</p>
<p>headers = {‘User-Agent’: user_agent}<br>data = urllib.urlencode(values)<br>req = urllib2.Request(url, data, headers)<br>cnt = 1<br>while cnt &lt;= 10000:<br>    response = urllib2.urlopen(req)<br>    print cnt<br>    cnt += 1<br>    time.sleep(1.0)<br>执行结果<br>这里写图片描述</p>
<p>方法四</p>
<p>这是方法三的升级，我们可以把Python代码交给Linux服务器去执行。<br>我使用的是openshift 免费空间，它空间很强，简直就是一个vps啊，可以shh链接，类linux操作。有兴趣的自己去申请一个，申请过程这里就不写了。</p>
<p>我们把方法三的代码保存为 work.py<br>然后让程序一直在后台跑就达到我们的目的了。执行命令：<br>nohup python work.py &amp;</p>
<p>这里写图片描述</p>
<p>最后结果</p>]]></content>
    
    <summary type="html">
    
      如何刷流量，不建议，没什么意义
    
    </summary>
    
      <category term="博客" scheme="http://code.youmeek.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="个人博客" scheme="http://code.youmeek.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="流量" scheme="http://code.youmeek.com/tags/%E6%B5%81%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>搭建网站</title>
    <link href="http://code.youmeek.com/2016/10/05/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"/>
    <id>http://code.youmeek.com/2016/10/05/搭建网站/</id>
    <published>2016-10-04T16:00:00.000Z</published>
    <updated>2017-01-24T08:09:47.897Z</updated>
    
    <content type="html"><![CDATA[<p>环境</p>
<p>Windows 10（64 位）<br>Git-2.7.4-64-bit<br>node-v4.4.7-x64<br>如果上述软件已经安装的，跳过，没有安装的下载安装。<br>1，git下载安装（<a href="https://git-for-windows.github.io/）" target="_blank" rel="external">https://git-for-windows.github.io/）</a></p>
<p>2，node下载安装（<a href="https://nodejs.org/en/）" target="_blank" rel="external">https://nodejs.org/en/）</a></p>
<p>3.安装npm工具（这里可以先不安装，我是之前做RN，所以已经安装好了）<br>4，验证安装是否成功。<br>     为了验证是否安装成功，我们在dos桌面输入如下的命令：<br>     git –version<br>     node -v<br>     npm –v<br>   出现如下表示成功</p>
<p>Github Pages</p>
<p>Github Pages免费的静态站点，其特点：免费托管、自带主题、支持自制页面等。<br>创建Github Pages比较简单，只要你有一个github账号在创建一个仓库就行了，但是这个仓库是有规则的，其格式必须为：yourusername.github.io。然后根据提示一直下一步即可，非常简单。</p>
<p>github项目创建完成，点击“Continue to layouts”，点击发布个人网站，我们网站就好了，不过这是一个github.io结尾的。</p>
<p>Hexo<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官网也是搭建在GitHub上。在电脑上新建一个blog文件夹,一般放在非c盘（非系统盘），该文件夹用于存放你的博客文件,然后右键单击选择“Git Bash”（你也可以打开hexo官网（<a href="https://hexo.io/zh-cn/）按提示的步骤来）。" target="_blank" rel="external">https://hexo.io/zh-cn/）按提示的步骤来）。</a></p>
<p>•npm install hexo-cli -g<br>•hexo init blog<br>•cd blog<br>•npm install<br>•hexo server</p>
<p>现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令：hexo server<br>现在用浏览器访问：<a href="http://localhost:4000/，效果如下图" target="_blank" rel="external">http://localhost:4000/，效果如下图</a></p>
<p>选用其他主题</p>
<p>由于默认主题太大众了，所以现在我们换个主题。你可以去这里找主题：</p>
<p>exo-theme：<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a><br>hexo-github-theme-list：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a><br>有那些好看的hexo主题？：<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="external">http://www.zhihu.com/question/24422335</a></p>
<p>我这里选择的 yelee：<a href="https://github.com/MOxFIVE/hexo-theme-yelee，如果你自己懂css.js，你可以自己写。输入命令：git" target="_blank" rel="external">https://github.com/MOxFIVE/hexo-theme-yelee，如果你自己懂css.js，你可以自己写。输入命令：git</a> clone <a href="https://github.com/MOxFIVE/hexo-theme-yelee.git" target="_blank" rel="external">https://github.com/MOxFIVE/hexo-theme-yelee.git</a> themes/yelee </p>
<p>找到_config.yml，把对应的主题目录名改下。</p>
<p>修改完成后，我们使用下面命令重新生成静态博客的所有内容：hexo generate，然后重启 hexo 本地服务：hexo server。</p>
<p>部署代码到github pages</p>
<p>创建好仓库之后，要本地生成 SSH 秘钥，方便电脑上的 git 软件好提交内容到 Github 上，其实也可以不生成本地的ssh，可以直接用命令或者工具上传代码（这个纯命令提交可以参考之前的博客点击打开链接），在 Git Bash 中，输入：ssh-keygen -t rsa -C “你的邮箱地址”，然后回车，回车，再回车，一共 3 次回车。</p>
<p>访问：<a href="https://github.com/settings/ssh，添加新秘钥" target="_blank" rel="external">https://github.com/settings/ssh，添加新秘钥</a></p>
<p>访接下来就是将本地的静态博客部署到gitHub上，要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件，可以实现如下命令：<br>npm install hexo -server –save<br>npm install hexo-deployer-git –save<br>编辑全局 hexo 的配置文件：_config.yml，这块可以参照网上的。<br>编辑全局配置后我们需要重新部署：<br>先清除掉已经生成的旧文件：hexo clean<br>再生成一次静态文件：hexo generate<br>在本地预览下：hexo server<br>本地没问题之后，Ctrl + C 停掉本地预览，使用部署命令部署到 Github 上：hexo deploy，有弹出下面提示框，请输入：yes</p>
<p>然后访问服务器地址进行检查：<a href="http://xiangzhihong.github.io" target="_blank" rel="external">http://xiangzhihong.github.io</a></p>
<p>通过上面几次流程我们也就可以总结：以后，每次发表新文章要部署都按这样的流程来：<br>hexo clean<br>hexo generate<br>hexo deploy<br>github pages绑定域名</p>
<p>绑定域名，这块比较坑，我参照网上很多的都没弄明白，这里是我摸索的一个方法。阿里云（万网）+github域名绑定。<br>购买域名</p>
<p>首先是在阿里云上购买域名，大家也可以上其实的域名交易平台购买。</p>
<p>域名解析</p>
<p>在阿里云管理控制台中,选择【域名】》【域名列表】》【全部域名】中刚刚购买的域名,点击解析按钮<br>这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在Github上创建的Github Pages的域名 xxx.github.io进行查询,得到一个IP地址。<br>admindeMacBook-Pro:blog admin$ ping xxx.github.io<br>PING prod.github.map.fastlylb.net (151.101.100.133): 56 data bytes<br>Request timeout for icmp_seq 0<br>64 bytes from 151.101.100.133: icmp_seq=1 ttl=47 time=69.632 ms</p>
<p>这里需要说明下，这里151.101.100.133是我的github的地址（就是xiangzhihong.github.io地址，你也可以ping自己的xx.github.io）.</p>
<p>如果你不会填，直接点上门的新手引导设置就好了。<br>Github解析</p>
<p>在Github的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。</p>
<p>备注：这里也可以用另一个工具去解析DNSPOD 。<br>设置好后，过一会就可以访问了，反正我的是很快，点击打开链接</p>
<p>整合 IntelliJ IDEA 提高效率<br>为了提交写作效率，我个人建议使用 IntelliJ IDEA 作为 Markdown 编辑工具，这也是前端开发的一个利器。现在我们用 IntelliJ IDEA 打开我们本地目录。</p>
<p>由于 IntelliJ IDEA 在 Windows 下的默认终端是 cmd 不好用，我们现在需要重新修改下 IntelliJ IDEA 的终端工具，把它指向我们习惯的 Git Bash，这样方便操作。</p>
<p>为了更稳定地使用 IntelliJ IDEA，在不修改主题的情况下，我们还需要这样做，hexo 新文章内容的开头需要这样定义：<br>categories：表示文章所属分类<br>tags：表示文章所属标签</p>
<h2 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h2><p>title: 这是文章标题<br>date: 2016-10-25 17:58:27<br>categories: [Hexo,IntelliJ IDEA]</p>
<h2 id="tags-Hexo-IntelliJ-IDEA-Git-Github-Node-js"><a href="#tags-Hexo-IntelliJ-IDEA-Git-Github-Node-js" class="headerlink" title="tags: [Hexo,IntelliJ IDEA,Git,Github,Node.js]"></a>tags: [Hexo,IntelliJ IDEA,Git,Github,Node.js]</h2><p>打开项目的module（快捷键ctrl+shift+alt+s）</p>]]></content>
    
    <summary type="html">
    
      搭建网站
    
    </summary>
    
      <category term="网站" scheme="http://code.youmeek.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="个人博客" scheme="http://code.youmeek.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="搭建网站" scheme="http://code.youmeek.com/tags/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
